var Mt = Object.defineProperty; var Et = (e, i, t) => i in e ? Mt(e, i, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[i] = t; var u = (e, i, t) => (Et(e, typeof i != "symbol" ? i + "" : i, t), t), X = (e, i, t) => { if (!i.has(e)) throw TypeError("Cannot " + t) }; var f = (e, i, t) => (X(e, i, "read from private field"), t ? t.call(e) : i.get(e)), E = (e, i, t) => { if (i.has(e)) throw TypeError("Cannot add the same private member more than once"); i instanceof WeakSet ? i.add(e) : i.set(e, t) }, U = (e, i, t, s) => (X(e, i, "write to private field"), s ? s.call(e, t) : i.set(e, t), t); var H = (e, i, t) => (X(e, i, "access private method"), t); import { ah as at, ai as Ht, aj as Rt, ak as Ot, al as D, A } from "./index-02d4e276.js"; import { d as V, w as M, r as K } from "./index-bb96cc25.js"; import { _ as _t } from "./preload-helper-41c905a7.js"; const Ct = !0, Ut = Ct; function Nt(e, i) { let t = !0; return function (...s) { t && (t = !1, e.apply(this, s), setTimeout(() => t = !0, i)) } } class nt { constructor(i) { u(this, "__target"); u(this, "_eventQueue", new WeakMap); this.__target = i } dispatch(i, t) { const s = this._eventQueue.get(this.__target); if (!s) return; const n = s.get(i); if (!n) return; const r = n.length; let o = -1; for (; ++o < r;)n[o](t) } dispose() { this._eventQueue !== null && this._eventQueue.delete(this.__target), this._eventQueue = null } off(i, t) { const s = this._eventQueue.get(this.__target); if (s) { if (i === void 0) { s.clear(); return } if (t === void 0) { s.delete(i); return } } } on(i, t) { if (!this.__target) return; const s = this._eventQueue.get(this.__target) ?? new Map, n = s.get(i) ?? []; s.set(i, n.concat(t)), this._eventQueue.set(this.__target, s) } once(i, t) { if (!this.__target) return; const s = n => { this.off(i, s), t(n) }; this.on(i, s) } } const G = new nt({}), Re = function () { return { send(e, i) { G.dispatch(e, i) }, listen(e, i) { G.on(e, i) }, dispose() { G.dispose() }, off(e, i) { G.off(e, i) } } }(); var P, L, b, O, $, B, gt, F, St; class Dt { constructor(i = 3) { E(this, O); E(this, B); E(this, F); E(this, P, []); E(this, L, []); E(this, b, void 0); U(this, b, i) } isLocked() { return f(this, b) <= 0 } async do(i) { const [t, s] = await this.acquire(); try { return await i() } finally { queueMicrotask(s) } } acquire(i = 1) { if (i <= 0) throw new Error("Value must be greater than 0. Received: #{value}"); return new Promise((t, s) => { f(this, P)[i - 1] || (f(this, P)[i - 1] = []), f(this, P)[i - 1].push({ resolve: t, reject: s }), H(this, O, $).call(this) }) } waitForUnlock(i = 1) { if (i <= 0) throw new Error("Value must be greater than 0. Received: #{value}"); return new Promise((t, s) => { f(this, L)[i - 1] || (f(this, L)[i - 1] = []), f(this, L)[i - 1].push(t), queueMicrotask(H(this, O, $)) }) } setValue(i) { U(this, b, i), H(this, O, $).call(this) } release(i) { U(this, b, f(this, b) + i), H(this, O, $).call(this) } getValue() { return f(this, b) } cancel() { const i = f(this, P).length; let t = -1; for (; ++t < i;) { const s = f(this, P)[t], n = s.length; let r = -1; for (; ++r < n;)s[r].reject(null) } U(this, P, []) } } P = new WeakMap, L = new WeakMap, b = new WeakMap, O = new WeakSet, $ = function () { var i; for (let t = f(this, b); t > 0; t--) { const s = (i = f(this, P)[t - 1]) == null ? void 0 : i.shift(); if (!s) continue; const n = f(this, b), r = t; U(this, b, f(this, b) - t), t = f(this, b) + 1, s.resolve([n, H(this, B, gt).call(this, r)]) } H(this, F, St).call(this) }, B = new WeakSet, gt = function (i) { let t = !1; return () => { t || (t = !0, this.release(i)) } }, F = new WeakSet, St = function () { for (let i = f(this, b); i > 0; i--)f(this, L)[i - 1] && (f(this, L)[i - 1].forEach(t => t()), f(this, L)[i - 1] = []) }; class xt extends Dt { constructor() { super(1) } } function Oe(e) { return Math.sqrt(1 - --e * e) } function zt(e) { const i = e - 1; return i * i * i + 1 } function Ce(e) { return e === 0 ? e : Math.pow(2, 10 * (e - 1)) } function Ue(e) { return e === 1 ? e : 1 - Math.pow(2, -10 * e) } function Ne(e) { return Math.pow(e, 4) } function De(e) { return Math.pow(e - 1, 3) * (1 - e) + 1 } function ze(e) { return --e * e * e * e * e + 1 } function $e(e) { const i = Math.cos(e * Math.PI * .5); return Math.abs(i) < 1e-14 ? 1 : 1 - i } function $t(e, i, t) { let s = t, n = e.length, r = -1; for (; ++r < n;)s = i(s, e[r], r, e); return n = null, r = null, s } function z(e, i) { for (let t = 0; t < e.length; t++)i(e[t], t, e) } function Vt(e, i) { const t = Array(e.length); for (let s = 0; s < e.length; s++)t[s] = i(e[s], s, e); return t } function Wt(e, i, t) { const s = []; for (let n = 0; n < e.length; n++) { const r = i(e[n], n, e); t(r) && s.push(r) } return s } function vt(e, i) { let t = -1, s = 0; const n = [], r = e.length; for (; ++t < r;)i(e[t]) && (n[s] = e[t], s++); return n } function bt(e, i, t, ...s) { const n = e.slice(i, i + t); let r = []; return s || (r = [...e.slice(0, i), ...e.slice(i + t)]), r = [...e.slice(0, i), ...s, ...e.slice(i + t)], e.length = 0, e.push.apply(e, r), n } function Qt(e, i) { let t = -1; const s = e.length; for (; ++t < s;)if (!i(e[t])) return !1; return !0 } const ot = { dev: "[DEV] ", debug: "[DEBUG] ", log: "[LOG] ", err: "[ERROR] " }; function jt(e) { Array.isArray(e) ? console.log(ot.debug, ...e) : console.log(ot.debug, e) } function Jt(...e) { arguments.length > 1 ? console.log("[LOG]", ...e) : console.log("[LOG]", e) } function Gt(...e) { arguments.length > 1 ? console.error("[ERROR]", ...e) : console.error("[ERROR]", e) } function qt(...e) { } const w = { dev: qt, debug: jt, log: Jt, err: Gt }; function lt() { } class Yt { constructor(i) { u(this, "_value"); u(this, "observers"); this._value = i, this.observers = [], this.subscribe = this.subscribe.bind(this), this.notifyObservers = this.notifyObservers.bind(this) } get value() { return this._value } subscribe(i) { return this.observers.push(i), i(this.value), () => { bt(this.observers, this.observers.indexOf(i), 1) } } notifyObservers(i) { z(this.observers, t => { t(this.value, i) }) } } class k extends Yt { constructor(i) { super(i), this.set = this.set.bind(this), this.update = this.update.bind(this), this.subscribe = this.subscribe.bind(this) } get value() { return this._value } set value(i) { if (this._value != i) { const t = this._value; this._value = i, this.onValueChanged(t) } } set(i) { this.value = i } async updateAsync(i) { this.value = await i(this.value) } update(i) { this.value = i(this.value) } onValueChanged(i) { this.notifyObservers(i) } } const W = (e, i, t) => { let s = t; const n = i.length < 2; let r = lt; const { subscribe: o } = V(e, (a, l) => { s = a; const h = i(a, l); if (n) l(h); else return r = typeof h == "function" ? h : lt, r }, t); return { subscribe: o, get value() { return s } } }, ct = { normal: "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", alternative: "useandom26T198340PX75pxJACKVERYMINDBUSHWOLFGQZbfghjklqvwyzrict" }, Bt = { generate: (e = 16, i = "normal") => { let t = "", s = e; for (; s--;)t += ct[i][Math.random() * ct[i].length | 0]; return t } }; function Ft(e = 16, i = "normal") { return Bt.generate(e, i) } function Pt(e) { let i = ""; for (const t in e) i += ` ${t}="${`${e[t]}`.toString().replace('"', '\\"')}"`; return i } function Kt(e) { let i = "<"; return e.name && (i += e.name), e.attrs && (i += Pt(e.attrs)), i += e.nodes || e.text ? ">" : "/>", e.text && (i += `${e.text}`.replace(/&amp;/g, "&").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), e.nodes && (i += Tt(e.nodes)), (e.nodes || e.text) && (i += `</${e.name}>`), i } function wt(e, i = 0) { return `<?xml${Pt(e.attrs)}?>` } function Tt(e) { return $t(e, (t, s) => { switch (s.type) { case "element": return t + Kt(s); case "declaration": return t + wt(s) } }, "") } function Xt(e) { let i = "", t = 0; return e.declaration && (i += wt(e.declaration, t)), e.nodes && (i += Tt(e.nodes)), console.log(i), i } function Zt(e) { return { type: "element", name: "Representation", attrs: { id: e.itag, codecs: e.mimeType.split(" ")[1].match(/"[^"]*/)[0].substr(1), bandwidth: e.bitrate }, nodes: [{ type: "element", name: "AudioChannelConfiguration", attrs: { schemeIdUri: "urn:mpeg:dash:23003:3:audio_channel_configuration:2011", value: "2" } }, { type: "element", name: "BaseURL", text: e.url }, { type: "element", name: "SegmentBase", attrs: { indexRange: `${e.indexRange.start}-${e.indexRange.end}` }, nodes: [{ type: "element", name: "Initialization", attrs: { range: `${e.initRange.start}-${e.initRange.end}` } }] }] } } function te(e) { return { type: "element", name: "Representation", attrs: { id: e.itag, codecs: e.mimeType.split(" ")[1].match(/"[^"]*/)[0].substr(1), bandwidth: e.bitrate, width: e.width, height: e.height, maxPlayoutRate: "1", frameRate: e.fps }, nodes: [{ type: "element", name: "BaseURL", text: e.url }, { type: "element", name: "SegmentBase", attrs: { indexRange: `${e.indexRange.start}-${e.indexRange.end}` }, nodes: [{ type: "element", name: "Initialization", attrs: { range: `${e.initRange.start}-${e.initRange.end}` } }] }] } } function ee(e) { const i = [], t = [], s = [[]]; z(e, n => { if (n.mimeType.indexOf("video") !== -1 && !(n != null && n.videoOnly)) return; const r = n.mimeType, o = t.indexOf(r); o > -1 ? s[o].push(n) : (t.push(r), s.push([]), s[t.length - 1].push(n)) }); for (let n = 0; n < t.length; n++) { let r = !1; const o = { type: "element", name: "AdaptationSet", attrs: { id: n, mimeType: t[n].split("; ")[0], startWithSAP: "1", subsegmentAlignment: "true" }, nodes: [] }; t[n].includes("audio") || (o.attrs.scanType = "progressive", r = !0), z(s[n], a => { r ? o.nodes.push(te(a)) : o.nodes.push(Zt(a)) }), i.push(o) } return i } function ie(e, i) { const t = { declaration: { type: "declaration", attrs: { version: "1.0", encoding: "utf-8" } }, nodes: [{ type: "element", name: "MPD", attrs: { xmlns: "urn:mpeg:dash:schema:mpd:2011", profiles: "urn:mpeg:dash:profile:full:2011", "xmlns:yt": "http://youtube.com/yt/2012/10/10", minBufferTime: "PT1.5S", type: "static", mediaPresentationDuration: `PT${i}S` }, nodes: [{ type: "element", name: "Period", nodes: ee(e) }] }] }; return Xt(t) } const se = e => { let i = e.replace("https://", "").split("/"); return i = i[2] !== void 0 ? i[2] : i[1], e = "https://redirector.googlevideo.com/" + i, e }; function ne({ data: e = {}, WebM: i = !1, dash: t = !1, proxyUrl: s = "" }) { var h, _, p, S, v, T; let n; if (t === !0) { const g = new URL(s), Q = Vt((h = e == null ? void 0 : e.streamingData) == null ? void 0 : h.adaptiveFormats, rt => { const J = new URL(rt.url), It = J.host; return J.host = g.host ?? "yt-hls-rewriter.onrender.com", J.searchParams.set("host", It), { ...rt, url: J.toString() } }), j = (_ = e == null ? void 0 : e.videoDetails) == null ? void 0 : _.lengthSeconds, kt = ie(Q, j); n = "data:application/dash+xml;charset=utf-8;base64," + btoa(kt) } const r = (S = (p = e == null ? void 0 : e.playerConfig) == null ? void 0 : p.hlsProxyConfig) == null ? void 0 : S.hlsChunkHost, o = (v = e == null ? void 0 : e.streamingData) == null ? void 0 : v.adaptiveFormats, a = ((T = e == null ? void 0 : e.streamingData) == null ? void 0 : T.hlsManifestUrl).replace(/https:\/\/(.*?)\//, s !== "" ? s : "https://yt-hls-rewriter.onrender.com/") + ("?host=" + r), l = Wt(o, g => { if (g.itag < 139 && g.itag > 251) return null; if (i === !0 && g.itag === 251) return { original_url: g.url, url: se(g.url), mimeType: "webm" }; if (g.itag === 140) return { original_url: g.url, url: g.url, mimeType: "mp4" } }, g => !!g); return { hls: a, dash: n, streams: l } } function ut(e) { return Object.prototype.toString.call(e) === "[object Date]" } function it(e, i) { if (e === i || e !== e) return () => e; const t = typeof e; if (t !== typeof i || Array.isArray(e) !== Array.isArray(i)) throw new Error("Cannot interpolate values of different type"); if (Array.isArray(e)) { const s = i.map((n, r) => it(e[r], n)); return n => s.map(r => r(n)) } if (t === "object") { if (!e || !i) throw new Error("Object cannot be null"); if (ut(e) && ut(i)) { e = e.getTime(), i = i.getTime(); const r = i - e; return o => new Date(e + o * r) } const s = Object.keys(i), n = {}; return s.forEach(r => { n[r] = it(e[r], i[r]) }), r => { const o = {}; return s.forEach(a => { o[a] = n[a](r) }), o } } if (t === "number") { const s = i - e; return n => e + n * s } throw new Error(`Cannot interpolate ${t} values`) } function re(e, i = {}) { const t = M(e); let s, n = e; function r(o, a) { if (e == null) return t.set(e = o), Promise.resolve(); n = o; let l = s, h = !1, { delay: _ = 0, duration: p = 400, easing: S = Ot, interpolate: v = it } = at(at({}, i), a); if (p === 0) return l && (l.abort(), l = null), t.set(e = n), Promise.resolve(); const T = Ht() + _; let g; return s = Rt(Q => { if (Q < T) return !0; h || (g = v(e, o), typeof p == "function" && (p = p(e, o)), h = !0), l && (l.abort(), l = null); const j = Q - T; return j > p ? (t.set(e = o), !1) : (t.set(e = g(S(j / p))), !0) }), s.promise } return { set: r, update: (o, a) => r(o(n, e), a), subscribe: t.subscribe } } const ae = "https://www.paypal.com/donate/?hosted_button_id=E6YRHKS2H2KP2"; let x = { appearance: { Theme: "Dark", "Immersive Queue": !0 }, playback: { "Dedupe Automix": !1, Quality: "Normal", "Prefer WebM Audio": !1, Stream: "HTTP" }, appinfo: { Donate: ae, GitHub: "https://github.com/snuffyDev/MusicTunes" }, network: { "HLS Stream Proxy": "https://yt-hls-rewriter.onrender.com/" }, search: { Preserve: "Category" } }; const oe = { YTM: "#010102", Dark: "#17171d", Dim: "#141820", Midnight: "#0f0916" }, le = e => { document.querySelector("meta[name='theme-color']").content = oe[e] }, I = ce(); function ce() { if (!("localStorage" in self)) return; const e = JSON.parse(localStorage.getItem("settings")); if (!(e != null && e.appearance) && !(e != null && e.playback) && !(e != null && e.search)) { const a = localStorage.getItem("theme"); x.appearance.Theme = a !== null ? a !== "ytm" ? a.slice(0).toUpperCase() + a.slice(1) : "YTM" : x.appearance.Theme, x.playback["Prefer WebM Audio"] = Boolean(localStorage.getItem("preferWebM")) ?? x.playback["Prefer WebM Audio"], x.playback["Dedupe Automix"] = Boolean(localStorage.getItem("theme")) ?? x.playback["Dedupe Automix"], localStorage.clear(), localStorage.setItem("settings", JSON.stringify(x)) } else e != null && e.network["HLS Stream Proxy"] || (e.network["HLS Stream Proxy"] = "https://yt-hls-rewriter.onrender.com/"), x = e; const i = M(x), { subscribe: t, update: s, set: n } = i; le(x.appearance.Theme); function r(a) { ht(a.appearance.Theme), localStorage.setItem("settings", JSON.stringify(x)) } function o(a, l, h) { x[a][l] = h, l === "Theme" && ht(h), s(_ => ({ [a]: { ..._[a], [l]: h }, ..._ })), r(x) } return { subscribe: t, change: o, value() { return D(i) }, set: a => { x = a, r(a), n(a) } } } function ht(e) { const i = document.documentElement, t = i.classList.item(0); i.classList.replace(t, e) } const ue = M(void 0), Ve = W(I, e => e.appearance.Theme), he = W(I, e => e == null ? void 0 : e.playback["Dedupe Automix"]); W(I, e => e == null ? void 0 : e.playback["Prefer WebM Audio"]); const We = W(I, e => { var i; return (i = e == null ? void 0 : e.search) == null ? void 0 : i.Preserve }), Qe = W(I, e => e == null ? void 0 : e.appearance["Immersive Queue"]), de = pe(); function pe() { const { set: e, subscribe: i, update: t } = M([]); let s = -1; return { subscribe: i, add: ({ msg: n, type: r, action: o }) => { t(a => [...a, { msg: n, type: r, action: o, id: ++s }]) }, remove: ({ id: n }) => { t(r => vt(r, o => o.id !== n)) } } } const je = fe(); function fe() { const e = new Set(["player-queue"]), { subscribe: i, set: t } = M(e); return { subscribe: i, add(s) { e.add(s), t(e) }, clear() { e.clear(), t(e) }, has(s) { return e.has(s) }, remove(s) { e.has(s) && e.delete(s) } } } const dt = M(!1), Je = M({ state: !1 }), Ge = M(!1), st = navigator.userAgent, me = /i(Phone|Pad|Pod)/i.test(st), ye = st.indexOf("Safari") > -1 && !/Chrome|Chromium|Edge?/i.test(st) || me, q = new Map, pt = () => { "mediaSession" in navigator && navigator.mediaSession.setPositionState({ duration: m.isWebkit ? m.duration / 2 : m.duration, position: m.currentTime }) }; function _e(e) { var i, t; if (e || (e = D(d)), "mediaSession" in navigator) { const s = e.position, n = e.mix[s]; navigator.mediaSession.metadata = new MediaMetadata({ title: n == null ? void 0 : n.title, artist: ((i = n == null ? void 0 : n.artistInfo) == null ? void 0 : i.artist[0].text) || null, album: ((t = n == null ? void 0 : n.album) == null ? void 0 : t.title) ?? void 0, artwork: [{ src: n == null ? void 0 : n.thumbnails[(n == null ? void 0 : n.thumbnails.length) - 1].url, sizes: `${n == null ? void 0 : n.thumbnails[(n == null ? void 0 : n.thumbnails.length) - 1].width}x${n == null ? void 0 : n.thumbnails[(n == null ? void 0 : n.thumbnails.length) - 1].height}`, type: "image/jpeg" }] }), navigator.mediaSession.setActionHandler("play", () => { m.play() }), navigator.mediaSession.setActionHandler("pause", () => m.pause()), navigator.mediaSession.setActionHandler("seekto", r => { if (r.fastSeek && "fastSeek" in m.player) { m.player.fastSeek(r.seekTime), pt(); return } m.seek(r.seekTime), pt() }), navigator.mediaSession.setActionHandler("previoustrack", () => m.previous()), navigator.mediaSession.setActionHandler("nexttrack", () => m.next()) } } const Z = e => c.sendGroupState(e), tt = (e, i) => c.send("PATCH", "state.update.position", { dir: e, position: i }, c.client); function ft(e) { if (typeof e != "string") throw Error(`Expected parameter 'currentUrl' to be a string, received ${e}`); const i = new URL(e); if (!i.hostname.includes("googlevideo.com")) return e; const [t, s, n] = i.hostname.split("."), r = i.searchParams.get("fvip"), o = i.searchParams.get("mn"); let [a, l] = t.split("---"); return a = a.replace(/\d/g, r), l = o.split(",")[1], i.hostname = `${`${a}---${l}`}.${s}.${n}`, i.toString() } function ge(e) { return e.url !== void 0 } class Se extends nt { constructor() { super({}); u(this, "_HLS"); u(this, "_HLSModule"); u(this, "_isDisposed", !1); u(this, "__srcUrl"); u(this, "__tick", !1); u(this, "__unsubscriber"); u(this, "_currentTime", 0); u(this, "_currentTimeStore", new k(0)); u(this, "_currentTimeUnsubscriber"); u(this, "_duration", 50); u(this, "_durationStore", new k(50)); u(this, "_durationUnsubscriber"); u(this, "_hasNextSrc", !1); u(this, "_initialized", !1); u(this, "_isWebkit", !1); u(this, "_nextTrackURL"); u(this, "_paused", new k(!0)); u(this, "_player"); u(this, "_remainingTime", 0); u(this, "_repeat", "off"); u(this, "playerType"); u(this, "_src", new k("")); u(this, "_worksWithHLSjs", new k(!1)); u(this, "_streamType"); u(this, "currentSessionList", () => D(d)); u(this, "errorCount", -1); u(this, "isHLSPlayer", !1); u(this, "progress", re(0, { duration: this._duration, easing: zt })); if ("window" in globalThis.self) { if (this._isWebkit = ye, this._player = new Audio, localStorage.getItem("volume")) this._player.volume = +localStorage.getItem("volume"); else { this._player.volume = .5; try { localStorage.setItem("volume", "0.5") } catch (t) { w.err("Cannot set item `volume` in localStorage", t) } } this._player.autoplay = !0, this._player.preload = "metadata", this._durationUnsubscriber = this._durationStore.subscribe(t => { this._duration = t }), this._currentTimeUnsubscriber = this._currentTimeStore.subscribe(t => { this._currentTime = t }), this.setup() } } get currentTime() { return this._player.currentTime ?? this._currentTime } get currentTimeStore() { return this._currentTimeStore } get duration() { return this._duration } get durationStore() { return this._durationStore } set isSeeking(t) { this.isSeeking = t } get isWebkit() { return this._isWebkit } get paused() { return this._paused } get player() { return this._player } get seeking() { return this.isSeeking } get src() { return this._src } set time(t) { this._currentTimeStore.set(t) } set volume(t) { if (!(!this._player && !Ut) && (this._player.volume = t, typeof localStorage < "u")) try { localStorage.setItem("volume", `${t}`) } catch (s) { w.err("Cannot save to localStorage", s) } } get hasFinishedPlayback() { return this._player.currentTime >= this._player.duration } dispose() { if (!this._isDisposed) { for (const [t, s] of q.entries()) s.options ? (this._player.removeEventListener(t, s.cb, s == null ? void 0 : s.options), q.delete(t)) : (this._player.removeEventListener(t, s.cb), q.delete(t)); this._currentTimeUnsubscriber(), this._durationUnsubscriber(), this.__unsubscriber(), super.dispose() } } async next(t = !1, s = !1) { if (this._repeat === "track" && t === !1 || this.__tick === !0) return; this.__tick = !0; const n = this.currentSessionList(), r = c.allCanPlay(); let o = n.position; if (this._repeat === "playlist" && n.position === n.mix.length - 1) { this.handleRepeat(n), this.__tick = !1; return } t === !0 && s === !0 ? (o = d.updatePosition("next"), n.mix.length - 1, tt("->", o - 1)) : o = d.updatePosition("next"), r && r.length && r[1](); const a = await this.getNextSongInQueue(o); if (a === null) { console.error("RESPONSE ERROR", new Error(`[err] ${a}`)); return } this.updateSrc(a), this.__tick = !1 } onEvent(t, s, n = {}) { this._player.addEventListener(t, s, n), q.set(t, { cb: s, options: n }) } pause() { "mediaSession" in navigator && (navigator.mediaSession.playbackState = "paused"), this._paused.set(!0), this._player.pause() } play(t = null) { try { "mediaSession" in navigator && (navigator.mediaSession.playbackState = "playing"), c.initialized === !0 && c.hasActiveSession === !0 && Z({ client: c.client.clientId, state: { finished: this.hasFinishedPlayback, paused: !1, playing: !0, pos: this.currentSessionList().position, stalled: !!this._player.error } }); const s = this._player.play(); s !== void 0 ? s.then(() => { this._player.play(), this._paused.set(!1) }).catch(n => { y(`${n.name}: ${n.message}`, "error") }) : (this._paused.set(!1), this.player.play()), this._player.defaultMuted = !1 } catch (s) { y("Error starting playback. You can find this error in the console logs as [playback-error]", "error"), console.error("[playback-error] ", s) } } previous(t = !1) { const s = this.currentSessionList().position; if (s === 0) { w.log("There's nothing that way!"); return } t === !0 && tt("<-", s), d.updatePosition("back"), this.getTrackSrc(s - 1) } seek(t) { if ("fastSeek" in this._player) { this._player.fastSeek(t); return } this.isHLSPlayer ? this._HLS.media.currentTime = t : this.player.currentTime = t, this._currentTimeStore.set(t) } skip() { this.currentTimeStore.set((this._player.duration - 1) * 2) } updateSrc(t) { if (t instanceof Promise) { t.then(s => { this.__srcUrl = s == null ? void 0 : s.original_url, this._src.set(s == null ? void 0 : s.url) }); return } this.__srcUrl = t == null ? void 0 : t.url, this._src.set(t == null ? void 0 : t.url) } updateTime(t) { this._currentTimeStore.set(t) } repeat(t) { t === "track" ? this._player.loop = !0 : this._player.loop = !1, this._repeat = t } async loadHLSModule() { return _t(() => import("./hls-dd7daf54.js").then(t => t.h), [], import.meta.url).then(t => t.default) } handleError() { ++this.errorCount > 2 && (this.errorCount = 0, this.updateSrc({ original_url: ft(this.player.src), url: ft(this.player.src) })) } async createHLSPlayer(t) { this.playerType !== "NATIVE" && (this._HLSModule || (this._HLSModule = await this.loadHLSModule()), this._HLSModule.isSupported() === !0 && (this._HLS && this._HLS.destroy(), this._HLS = new this._HLSModule({ lowLatencyMode: !0, enableWorker: !0, backBufferLength: 90 }), this._HLS.attachMedia(this._player), this._HLS.on(this._HLSModule.Events.MEDIA_ATTACHED, () => { this._HLS.loadSource(t) }), this._HLS.on(this._HLSModule.Events.ERROR, (s, n) => { switch (n.type) { case this._HLSModule.ErrorTypes.MEDIA_ERROR: this._HLS.recoverMediaError(); break; case this._HLSModule.ErrorTypes.NETWORK_ERROR: this._HLS.startLoad(); break } }))) } async getNextSongInQueue(t, s = !0) { var r, o; const n = this.currentSessionList(); if (n.position >= n.mix.length - 1) return c.initialized && c.hasActiveSession && c.client.role !== "host" ? await this.getTrackSrc(t, s) : n.currentMixType !== "playlist" && !n.continuation && !n.clickTrackingParams ? await this.handleAutoSuggestion(n.position) : d.getSessionContinuation({ itct: (r = n.mix[n.position]) == null ? void 0 : r.itct, videoId: (o = n.mix[n.position]) == null ? void 0 : o.videoId, playlistId: n.currentMixId, loggingContext: n.mix[n.position].loggingContext, ctoken: n.continuation, clickTrackingParams: n.clickTrackingParams, key: n.position }); try { return this.__tick = !1, await this.getTrackSrc(t, s).then(l => { if (ge(l)) return l }) } catch { } } getTrackSrc(t, s = !0) { const n = this.currentSessionList(); return R(n.mix[t].videoId, n.mix[t].playlistId, null, s).then(({ body: r, error: o }) => o === !0 ? (this.skip(), o) : r).catch(r => { r.message.includes("The play() request was interrupted") || y(`${r.name}: ${r.message}`, "error") }) } async handleAutoSuggestion(t) { const s = this.currentSessionList(); return await d.getMoreLikeThis({ playlistId: s.currentMixId }), this.getTrackSrc(t).then(n => { function r(o) { return o.url !== void 0 } if (r(n)) return n }) } async handleRepeat(t) { t.position === t.mix.length - 1 && (d.updatePosition(1), await A(), this.previous(!1)), this.__tick = !1 } async onEnded() { var n; if (this._repeat === "track") return; const t = this.currentSessionList(), s = t.position === t.mix.length - 1; if (this._repeat === "playlist" && s) { await this.handleRepeat(t); return } if (s) { d.next(); return } if (c.initialized) { Promise.resolve(Z({ client: c.client.clientId, state: { finished: this.hasFinishedPlayback, paused: !0, playing: !1, pos: this.currentSessionList().position, stalled: !!this._player.error } })).then(() => { const [r, o] = c.allCanPlay(); r && o() }); return } if (this._hasNextSrc === !0 && this._nextTrackURL && ((n = this._nextTrackURL) != null && n.url)) d.updatePosition("next"), this.updateSrc(this._nextTrackURL); else { const r = d.updatePosition("next"); this.getNextSongInQueue(r, !1).then(o => (this._nextTrackURL = o, this.updateSrc(o), o)) } this._hasNextSrc = !1, this._nextTrackURL = null } async canUseHLSjs() { var s, n; const t = ((n = (s = D(I)) == null ? void 0 : s.playback) == null ? void 0 : n.Stream) === "HLS"; return t === !0 ? this._streamType = "HLS" : this._streamType = "HTTP", this.isWebkit && t ? (this.isHLSPlayer = !0, "NATIVE") : t && (this._HLSModule || (this._HLSModule = await this.loadHLSModule()), this._HLSModule.isSupported()) ? (this.isHLSPlayer = !0, "HLS.JS") : (this.isHLSPlayer = !1, "UNSUPPORTED") } async setup() { this.playerType = await this.canUseHLSjs(), this.__unsubscriber = this._src.subscribe(async t => { this.playerType === "HLS.JS" && !this._HLSModule && (this._HLSModule = await this.loadHLSModule()), this.isHLSPlayer && this.playerType === "HLS.JS" ? this.createHLSPlayer(t) : (this._HLS && this._HLS.destroy(), this._player.src = t, this._player.load()) }), this.on("play", async t => { this._initialized || (await this.updateSrc(t[0]), this._player.autoplay = !0, this.play()) }), this.on("update:stream_type", async ({ type: t }) => { if (t === "HLS") { if (this.playerType = await this.canUseHLSjs(), this.playerType !== "HLS.JS") return; this._HLSModule || (this._HLSModule = await this.loadHLSModule()), this._HLSModule.isSupported() && (this.isHLSPlayer = !0) } t === "HTTP" && (this._streamType = "HTTP", this.isHLSPlayer = !1, this.isHLSPlayer && this._HLS && this._HLS.destroy()) }), this.onEvent("play", async () => { try { "mediaSession" in navigator && (navigator.mediaSession.playbackState = "playing"), c.initialized === !0 && c.hasActiveSession === !0 && Z({ client: c.client.clientId, state: { finished: this.hasFinishedPlayback, paused: !1, playing: !0, pos: this.currentSessionList().position, stalled: !!this._player.error } }); const t = this._player.play(); t !== void 0 ? t.then(() => { this._player.play(), this._paused.set(!1) }).catch(s => { y(`${s.name}: ${s.message}`, "error") }) : (this._paused.set(!1), this.player.play()) } catch (t) { this.handleError(), y(`Error: ${t}`, "error") } }), this.onEvent("pause", () => this.pause()), this.onEvent("seeked", () => { this._src.value && this.play() }), this.onEvent("loadedmetadata", () => { var s, n; this.__tick = !1, this._hasNextSrc = !1, this._nextTrackURL = null, this._durationStore.set(this._player.duration); const t = D(d); ue.set((s = t.mix[t.position]) == null ? void 0 : s.title), window.bbPlayer = { src: this.__srcUrl, duration: this.duration, title: (n = t.mix[t.position]) == null ? void 0 : n.title }, _e(t), this.dispatch("playing") }), this.onEvent("timeupdate", async () => { if (this._currentTimeStore.set(this._player.currentTime), this._durationStore.set(this._isWebkit && !this.isHLSPlayer ? this._player.duration / 2 : this._player.duration), !this._hasNextSrc && this.isWebkit && !this.isHLSPlayer ? this._player.currentTime * 2 >= this._player.duration / 4 : this._player.currentTime >= this._player.duration / 2) { if (this._hasNextSrc === !0) return; this.getNextSongInQueue(this.currentSessionList().position + 1, !1).then(t => { this._nextTrackURL = t }), this._hasNextSrc = !0 } this.progress.set(this._isWebkit && !this.isHLSPlayer ? this._player.currentTime * 2 : this._player.currentTime), this._isWebkit && this.isHLSPlayer === !1 && this._currentTime >= this._duration && this.onEnded() }), this.onEvent("ended", async () => this.onEnded()), this.onEvent("error", t => { this._player.error.message.includes("Empty src") || !this._player.error.message || (console.error(this._player.error), this.handleError()) }) } } const m = new Se; function xe({ original_url: e, url: i }) { m.updateSrc({ original_url: e, url: i }) } let C; globalThis.self.name !== "IDB" && I && I.subscribe(e => { C = e }); const y = (e, i, t) => { de.add({ msg: e, type: i, action: t }) }; function et(e, i) { let t; if (typeof i == "number") { let s = i; t = () => { const n = Math.sin(s++) * 179426549; return n - Math.floor(n) } } else t = Math.random; for (let s = e.length - 1; s > 0; s -= 1) { const n = Math.floor(t() * (s + 1)), r = e[s]; e[s] = e[n], e[n] = r } return e } function qe(e) { if (isNaN(e)) return "..."; const i = Math.floor(e / 60); return e = Math.floor(e % 60), e < 10 && (e = "0" + e), `${i}:${e}` } const ve = async ({ videoId: e, playlistId: i }) => { try { const t = `/api/v1/get_queue.json${e ? `?videoIds=${e}` : i ? "?playlistId=" + i : ""}`, s = await fetch(t, { headers: { accept: "application/json" } }).then(n => n.json()).catch(n => console.log(n)); if (Array.isArray(s)) return s } catch (t) { console.error(t), y(t, "error") } }, R = async (e, i, t, s = !0) => { try { const n = await fetch(`/api/v1/player.json?videoId=${e}${i ? `&playlistId=${i}` : ""}${t ? `&playerParams=${t}` : ""}`).then(a => a.json()); if (n && !(n != null && n.streamingData) && (n == null ? void 0 : n.playabilityStatus.status) === "UNPLAYABLE") return Pe(); const r = ne({ data: n, dash: !1, proxyUrl: (C == null ? void 0 : C.network["HLS Stream Proxy"]) ?? "" }); return be(r, s) } catch (n) { console.error(n), y(n, "error") } }; function be(e, i) { var s; let t; return ((s = C == null ? void 0 : C.playback) == null ? void 0 : s.Stream) === "HLS" ? t = { original_url: e == null ? void 0 : e.hls, url: e.hls } : t = e.streams[0], i && xe({ original_url: t.original_url, url: t.url }), { body: { original_url: t.original_url, url: t.url }, error: !1 } } function Pe() { return console.log("error"), y("An error occurred while initiating playback, skipping...", "error", "getNextTrack"), { body: null, error: !0 } } const we = e => { const i = []; let t = ""; for (t in e) typeof e[t] != "number" && !e[t] || i.push(`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`); return i.join("&") }; function Te(e = []) { return e.filter((i => t => !i.has(t.videoId) && i.add(t.videoId))(new Set)) } function N(e = {}) { const i = we(e); return fetch("/api/v1/next.json?" + i, { headers: { accept: "application/json" } }).then(t => t.json()).catch(t => { console.error(t) }) } const mt = new xt; function Y() { return dt.set(!0), () => dt.set(!1) } const yt = ["clickTrackingParams", "continuation", "currentMixId", "currentMixType", "visitorData", "related", "mix", "position"]; class Le { constructor() { u(this, "$", new k(void 0)); u(this, "state", { clickTrackingParams: "", continuation: "", currentMixId: "", currentMixType: null, visitorData: "", mix: [], position: 0, related: null }); this.$.set(this.state) } get clickTrackingParams() { return this.state.clickTrackingParams } get continuation() { return this.state.continuation } get currentMixId() { return this.state.currentMixId } get mix() { return this.state.mix.slice() } get position() { return this.state.position } get set() { return this.$.set } get value() { return this.state } get subscribe() { return this.$.subscribe } get update() { return this.$.update } currentTrack(i = 0) { var t; return (t = this.state.mix) == null ? void 0 : t[i] } async next(i = !1, t = !1) { var o, a, l; let s = this.state.position + 1; s >= this.state.mix.length && (s = this.state.position); const n = this.currentTrack(s), r = await N({ visitorData: (o = this.state) == null ? void 0 : o.visitorData, params: encodeURIComponent("OAHyAQIIAQ=="), playlistSetVideoId: n == null ? void 0 : n.playlistSetVideoId, index: s, loggingContext: (l = (a = n == null ? void 0 : n.loggingContext) == null ? void 0 : a.vssLoggingContext) == null ? void 0 : l.serializedContextData, videoId: n == null ? void 0 : n.videoId, playlistId: this.currentMixId, clickTracking: this == null ? void 0 : this.clickTrackingParams }); r && (await this.sanitizeAndUpdate("APPLY", r), await m.next(i, t)) } async previous(i = !1) { var s, n, r, o, a, l; const t = await N({ visitorData: (s = this.state) == null ? void 0 : s.visitorData, params: encodeURIComponent("OAHyAQIIAQ=="), playlistSetVideoId: (n = this.state.mix[this.position]) == null ? void 0 : n.playlistSetVideoId, index: this.state.position, loggingContext: (a = (o = (r = this.currentTrack) == null ? void 0 : r.loggingContext) == null ? void 0 : o.vssLoggingContext) == null ? void 0 : a.serializedContextData, videoId: (l = this.currentTrack) == null ? void 0 : l.videoId, playlistId: this.currentMixId, ctoken: this == null ? void 0 : this.continuation, clickTracking: this == null ? void 0 : this.clickTrackingParams }); t && (this.state.related = t.related, await this.sanitizeAndUpdate("APPLY", t), await m.next(!0, !0)) } async getMoreLikeThis({ playlistId: i }) { const t = Y(); await A(); try { const s = await N({ params: "wAEB8gECeAE%3D", playlistId: i !== null ? i.startsWith("RDAMPL") ? i : "RDAMPL" + i : this.state.currentMixId }); if (!s || !s.results.length) throw new Error("Invalid response returned by `next` endpoint"); this.state.mix.length && s.results.shift(); const n = await this.sanitizeAndUpdate("APPLY", { ...s, mix: ["append", s.results] }); c != null && c.initialized && (c != null && c.hasActiveSession) && c.updateGuestTrackQueue(n), await R(this.state.mix[this.state.position + 1].videoId, this.state.mix[this.state.position].playlistId, null, !1) } catch (s) { w.err(s), y(s, "error") } finally { t() } } async getSessionContinuation({ clickTrackingParams: i, ctoken: t, itct: s, key: n, playlistId: r, videoId: o, loggingContext: a }) { var h, _; const l = Y(); await A(); try { !i && !t && (r = r.startsWith("RDAMPL") ? r : "RDAMPL" + r, s = "wAEB8gECeAE%3D"); const p = await N({ visitorData: this.state.visitorData, params: encodeURIComponent("OAHyAQIIAQ=="), playlistSetVideoId: (h = this.state.mix[n]) == null ? void 0 : h.playlistSetVideoId, index: n, loggingContext: (_ = a == null ? void 0 : a.vssLoggingContext) == null ? void 0 : _.serializedContextData, videoId: o, playlistId: r, ctoken: t, clickTracking: i }); if (!p || !(Array.isArray(p.results) && p.results.length)) { this.getMoreLikeThis({ playlistId: r }); return } const S = p.results, v = await this.sanitizeAndUpdate("APPLY", { ...p, mix: ["append", S] }), T = await R(this.state.mix[n].videoId); return c != null && c.initialized && (c != null && c.hasActiveSession) && c.updateGuestContinuation(v), T.body } catch (p) { w.err(p) } finally { l() } } async initAutoMixSession(i) { var s; const t = Y(); try { const { loggingContext: n, keyId: r, clickTracking: o, config: a, playlistId: l, playlistSetVideoId: h, videoId: _ } = i; await A(); let p = !1; this.state.mix && (p = !0, this.revertState()), this.state.currentMixType = "auto"; const S = await N({ params: a != null && a.playerParams ? a == null ? void 0 : a.playerParams : void 0, videoId: _, playlistId: l || void 0, loggingContext: n ? (s = n.vssLoggingContext) == null ? void 0 : s.serializedContextData : void 0, playlistSetVideoId: h || void 0, clickTracking: o, configType: (a == null ? void 0 : a.type) || void 0 }); if (!S || !Array.isArray(S.results)) throw new Error("Invalid response was returned from `next` endpoint."); const v = S.results[r ?? 0]; R(_ ?? (v == null ? void 0 : v.videoId), v == null ? void 0 : v.playlistId, a == null ? void 0 : a.playerParams); const T = await this.sanitizeAndUpdate(p ? "SET" : "APPLY", { ...this.state, ...S, mix: ["append", S.results] }); c != null && c.initialized && (c != null && c.hasActiveSession) && c.expAutoMix(T) } catch (n) { w.err(n) } finally { t() } } async initPlaylistSession(i) { var s; const t = Y(); try { let { playlistId: n = "", index: r = 0, clickTrackingParams: o = "", params: a = "", videoId: l = "", playlistSetVideoId: h = "", visitorData: _ = "" } = i; await A(), console.log("this.initPlaylistSession"), (this.state.currentMixType !== "playlist" || this.state.currentMixId !== n) && this.updatePosition(typeof r == "number" ? r : 0), this.state.currentMixId !== n && this.revertState(); const p = await N({ params: a, playlistId: n.startsWith("VL") ? n.slice(2) : n, clickTracking: o, visitorData: _, playlistSetVideoId: h, videoId: l }); if (!p || !Array.isArray(p.results)) throw new Error("Invalid response returned from `next` endpoint."); if (!p.results.length) { this.getMoreLikeThis({ playlistId: n }); return } const S = await this.sanitizeAndUpdate("APPLY", { ...p, mix: ["set", p.results], currentMixType: "playlist" }); return await A(), c != null && c.initialized && (c != null && c.hasActiveSession) && c.expAutoMix(S), await R((s = this.state.mix[r]) == null ? void 0 : s.videoId, n, null, !0) } catch (n) { return w.err(n), y("Error starting playlist playback.", "error"), null } finally { t() } } lockedSet(i) { return mt.do(async () => (this.$.set(i), Promise.resolve(this.state))) } removeTrack(i) { this.state.mix.splice(i, 1), this.$.update(t => ({ ...t, mix: [...t.mix.slice(0, i), ...t.mix.slice(i + 1)] })) } async setMix(i, t) { const s = await mt.do(async () => (await A(), new Promise(n => { this.sanitizeAndUpdate("SET", { ...this.state, mix: ["set", i], currentMixType: t }), n(this.state) }))); c != null && c.initialized && (c != null && c.hasActiveSession) && c.send("PUT", "state.set.mix", JSON.stringify(s), c.client) } async setTrackWillPlayNext(i, t) { if (await A(), !i) { y("No track to remove was provided!", "error"); return } try { const s = await ve(i), n = this.state.mix.length; bt(this.state.mix, t + 1, 0, ...s), await this.sanitizeAndUpdate("APPLY", { mix: ["set", this.state.mix] }), n || await R(this.state.mix[0].videoId, this.state.mix[0].playlistId, null, !0) } catch (s) { console.error(s), y(`Error: ${s}`, "error") } } shuffle(i, t = !0) { if (typeof i != "number") return; t ? this.state.mix = [...this.state.mix.slice().slice(0, i), this.state.mix[i], ...et(this.state.mix.slice().slice(i + 1), crypto.getRandomValues(new Uint8Array(8)).reduce((n, r) => n += r, 0))] : this.state.mix = et(this.state.mix.slice(), crypto.getRandomValues(new Uint8Array(8)).reduce((n, r) => n += r, 0)); const s = this.sanitizeAndUpdate("APPLY", { mix: this.state.mix }); c != null && c.initialized && (c != null && c.hasActiveSession) && c.updateGuestTrackQueue(s) } shuffleRandom(i) { this.state.mix = et(i, crypto.getRandomValues(new Uint8Array(8)).reduce((s, n) => s += n, 0)); const t = this.sanitizeAndUpdate("SET", { mix: this.state.mix }); c != null && c.initialized && (c != null && c.hasActiveSession) && c.updateGuestTrackQueue(t) } toJSON() { return JSON.stringify(this.state) } updatePosition(i) { return typeof i == "number" ? (this.sanitizeAndUpdate("APPLY", { position: i }), i) : (i === "next" && this.sanitizeAndUpdate("APPLY", { position: this.state.position + 1 }), i === "back" && this.sanitizeAndUpdate("APPLY", { position: this.state.position - 1 }), this.state.position) } revertState() { return this.state = { clickTrackingParams: "", continuation: "", currentMixId: "", currentMixType: null, mix: [], visitorData: "", position: 0, related: null }, this.state } async sanitizeAndUpdate(i, t) { return await this.$.updateAsync(s => new Promise(n => { var r, o; if (i === "APPLY") { let a, l; for (a in t) if (l = t[a], l != null && l != null) { if (!yt.includes(a)) { console.log("SKIPPING INVALID KEY", a); continue } if (a === "related" && ((r = s[a]) == null ? void 0 : r.browseId) === ((o = t[a]) == null ? void 0 : o.browseId)) { s.related = null; continue } if (s[a] === t[a]) { console.log("SKIPPING UNCHANGED", a); continue } a === "mix" ? (t.mix[0] === "append" ? s.mix.push(...t.mix[1]) : t.mix[0] === "set" && (s.mix = t.mix[1]), he.value && (s.mix = Te(s.mix))) : t[a] !== void 0 && t[a] !== null && (s[a] = t[a]) } Object.assign(this.state, s), n({ ...s, ...this.state }) } else { const { mix: a } = t; for (const l in t) yt.includes(l) || delete t[l]; n({ ...t, mix: a[1] ? a[1] : s.mix }) } })), this.$.value } } const Ae = new Le, d = Ae, Ye = V(d, e => e.mix), Be = V(d, e => e.mix[e.position]), Fe = V(d, e => e.position), Ke = (() => { let e; const { subscribe: i } = V(d, (t, s) => { try { (async () => { var n; t.position !== e && t.related !== null && await fetch(`/api/v1/related.json?browseId=${(n = t.related) == null ? void 0 : n.browseId}`).then(r => r.json()).then(s) })() } catch (n) { w.err(n) } }); return { subscribe: i } })(); class ke extends nt { constructor() { super({}); u(this, "_allCanPlay", !1); u(this, "_client"); u(this, "_connection"); u(this, "_connectionStates", new k({})); u(this, "_connections", []); u(this, "_hasActiveSession", !1); u(this, "_history", new k([])); u(this, "_initialized", !1); u(this, "_once", !1); u(this, "_peerIds", new Set([])); u(this, "_peerJs"); u(this, "_rtc"); u(this, "_settings"); u(this, "_type"); u(this, "_unsubscriber"); u(this, "_lock"); this._lock = new xt, _t(() => import("./bundler-b36eb39b.js"), [], import.meta.url).then(t => { this._peerJs = t.default }), this._unsubscriber = this._connectionStates.subscribe(async t => { const s = Object.values(t); !this._once && !this._allCanPlay && s.length !== 0 && Qt(s, n => (n == null ? void 0 : n.finished) === !0) === !0 && (this._once = !0, this._allCanPlay = !0, await d.next(!0, !1), setTimeout(() => this._once = !1, 25)) }) } get client() { return this._client } get connection() { return this._connection } get connections() { return this._connections } get hasActiveSession() { return this._hasActiveSession } get history() { return this._history } get initialized() { return this._initialized } get rtc() { return this._rtc } get settings() { return this._settings } get type() { return this._type } async addToQueue(t, s) { !this.initialized && !this.hasActiveSession || await this._lock.do(() => { d.setTrackWillPlayNext(t, s).then(() => { this.send("PUT", "state.update.mix", d.toJSON(), this.client) }) }) } allCanPlay() { return [this._allCanPlay, () => { this._once = !1, this._allCanPlay = !1 }] } connect(t) { if (!this._rtc) return; if (this._peerIds.has(t)) return y(`Already connected to peer ${t}!`, "error"); this._hasActiveSession || (this._hasActiveSession = !0); const s = this._rtc.connect(t, { metadata: { clientId: this.client.clientId, displayName: this.client.displayName, permissions: {}, role: "guest" }, reliable: !0, serialization: "binary" }); this._peerIds.add(t), this._connections.push(s), this.listenToConnection(s), s.on("open", () => { w.debug(`Established connection to ${t}`), y(`Connected to ${s.peer}`, "success") }), s.on("close", () => { this.disconnect() }) } disconnect() { this._peerIds.clear(), this.type === "guest" && (this._connection.close(), this._rtc.destroy()), z(this._connections, t => { t.close() }), this._rtc.destroy(), this._unsubscriber(), this._hasActiveSession = !1, this._initialized = !1, this._connectionStates.set(null) } expAutoMix(t) { this.send("PUT", "state.set.mix", JSON.stringify(t), this.client) } init(t, s, n = { forceSync: !0 }) { if (this.initialized) return; this._initialized = !0, this._settings = n; const r = "bbgs_" + Ft(9, "alternative"); this._client = { clientId: r, displayName: t, role: s || "guest" }, this._rtc = new this._peerJs(r, { debug: 3 }), this._hasActiveSession || (this._hasActiveSession = !0), this._connectionStates.update(o => ({ ...o, [this._client.clientId]: { finished: !1, paused: !1, playing: !1, pos: 0, stalled: !1 } })), this._rtc.on("open", o => { s === "host" && this.initSession(), this.dispatch("init") }) } process(t) { if (typeof t != "string") return; const { command: s, data: n, metadata: r, type: o } = JSON.parse(t); if (r.clientId !== this.client.clientId) return this._lock.do(() => { var a; if (s === "GET" && o === "action.mix.init" && d.initAutoMixSession({ videoId: n }), s === "CONFIG" && (this._settings = n), s === "PUT") { if (o === "state.set.mix") try { const l = JSON.parse(n); d.set(l), R(l.mix[l.position].videoId, l.mix[l.position].playlistId).then(h => { m.updateSrc(h.body), m.play() }) } catch (l) { if (l.message) { console.log(l); const h = parseInt((a = l.message.match(/\d+$/g)) == null ? void 0 : a.at(0)); l.message.includes("position") ? console.log(n.slice(0, h), n.slice(h)) : console.error(l) } } if (o === "state.update.continuation") { const l = JSON.parse(n); if (!l.mix && !l.mix.length) throw new Error("Provided SessionList is not valid!", {}); new Promise(h => { setTimeout(() => { h(d.lockedSet(l)) }) }).then(h => { d.updatePosition(h.position - 1), d.next(!0, !1) }) } if (s === "PUT" && o === "state.update.mix") try { const l = JSON.parse(n); if (!l.mix && !l.mix.length) throw new Error("Provided SessionList is not valid!", {}); d.set(l) } catch { console.error() } } if (s === "PATCH") { if (o === "state.update.position") { const { dir: l = void 0, position: h = 0 } = n; d.updatePosition(h === 0 ? 0 : h), typeof l > "u" && m.skip(), l === "<-" ? m.previous(!1) : l === "->" && d.next(!0, !1) } o === "state" && this._connectionStates.update(l => ({ ...l, [n.client]: n.state })) } return { command: s, data: n, metadata: r, type: o } }) } send(t, s, n, r) { this._initialized && z(this._connections, o => { this.client.clientId !== o.peer && r.clientId !== o.peer && o.send(JSON.stringify({ command: t, type: s, data: n, metadata: this.client }), !0) }) } sendGroupState(t) { this._connectionStates.update(s => ({ ...s, [this.client.clientId]: t.state })), this.send("PATCH", "state", t, this.client) } setAutoMix(t, { videoId: s = "", playlistId: n = "" }) { return this.initializeHostPlayback("automix", { videoId: s, playlistId: n }) } setPlaylistMix(t = "") { return this.initializeHostPlayback("playlist", { playlistId: t }) } updateGuestContinuation(t) { this.send("PUT", "state.update.continuation", JSON.stringify(t), this._client) } updateGuestTrackQueue(t) { this.send("PUT", "state.update.mix", JSON.stringify(t), this._client) } initSession() { y("Started Host Session", "success"), this._connectionStates.update(t => ({ ...t, [this.client.clientId]: { finished: !1, paused: !0, playing: !1, pos: 0, stalled: !1 } })), this._rtc.on("connection", t => { this._connections.push(t), this.listenToConnection(t), w.debug("Received connection"), t.on("open", () => { this._peerIds.add(t.peer), t.send(JSON.stringify({ data: this.settings, command: "CONFIG", metadata: this.client, type: "state" })), t.send(JSON.stringify({ data: [...this._peerIds.values()], command: "CONNECT", metadata: this.client, type: "action" })), D(d).mix.length && t.send(JSON.stringify({ command: "PUT", type: "state.set.mix", data: d.toJSON(), metadata: this.client }), !0) }) }) } initializeHostPlayback(t, s = { videoId: "", playlistId: "" }) { try { return t === "automix" ? d.initAutoMixSession({ videoId: s == null ? void 0 : s.videoId, playlistId: s == null ? void 0 : s.playlistId }).then(() => { this.send("PUT", "state.set.mix", d.toJSON(), this.client) }) : t === "playlist" && d.initPlaylistSession({ index: 0, playlistId: s == null ? void 0 : s.playlistId }).then(() => { this.send("PUT", "state.set.mix", d.toJSON(), this.client) }), "OK" } catch (n) { return console.error(n), "ERROR" } } listenToConnection(t) { t.on("data", async s => { const n = await this.process(s); if (n.metadata.clientId === this.client.clientId) return y(n.metadata.clientId + "  " + this.client.clientId, "error"); if (n.command === "CONNECT" && Array.isArray(n.data)) { const r = vt(n.data, a => a !== this.client.clientId), o = Object.keys(this._rtc.connections); z(r, a => { o.includes(a) || this.connect(a) }); return } this.send(n.command, n.type, n.data, n.metadata) }), t.on("close", () => { this._connectionStates.update(s => ({ ...s, [t.peer]: null })) }) } } const c = new ke; function Lt(e) { return i => { let t = () => { }; { const s = window.matchMedia(e), n = () => i(s.matches); s.addEventListener("change", n), n(), t = () => s.removeEventListener("change", n) } return t } } const Xe = K(!1, Lt("screen and (max-width: 719px)")), Ze = K(!1, Lt("screen and (min-width: 720px)")); function At(e) { return i => { const t = Nt(n => { requestAnimationFrame(() => { i(window[e]) }) }, 80); let s = () => { }; return i(window[e]), window.addEventListener("resize", t), s = () => window.removeEventListener("resize", t), s } } const ti = K(0, At("innerWidth")), ei = K(0, At("innerHeight")); export { m as A, Qe as B, je as C, Ne as D, tt as E, Ze as F, ue as G, Ut as H, Ft as I, vt as J, ze as K, w as L, R as M, Vt as N, I as O, Oe as a, Be as b, zt as c, ti as d, Ye as e, qe as f, Ce as g, dt as h, Fe as i, Xe as j, c as k, d as l, Re as m, Je as n, y as o, We as p, De as q, Ge as r, $e as s, re as t, de as u, Ue as v, ei as w, Ke as x, Ve as y, he as z };
