import { c as Ke, s as Xe, v as F, m as M } from "./chunks/index.js"; import { D as ie } from "./chunks/prod-ssr.js"; import { H as U, R as C, e as Z, A as ee, j as je } from "./chunks/index2.js"; import *as I from "devalue"; import { r as Qe, w as ce } from "./chunks/index3.js"; import { parse as W, serialize as xe } from "cookie"; import *as le from "set-cookie-parser"; const Ze = Ke((e, t, n, r) => {
	let { stores: s } = t, { page: a } = t, { components: o } = t, { form: i } = t, { data_0: c = null } = t, { data_1: f = null } = t; return Xe("__svelte__", s), s.page.notify, t.stores === void 0 && n.stores && s !== void 0 && n.stores(s), t.page === void 0 && n.page && a !== void 0 && n.page(a), t.components === void 0 && n.components && o !== void 0 && n.components(o), t.form === void 0 && n.form && i !== void 0 && n.form(i), t.data_0 === void 0 && n.data_0 && c !== void 0 && n.data_0(c), t.data_1 === void 0 && n.data_1 && f !== void 0 && n.data_1(f), s.page.set(a), `


${o[1] ? `${F(o[0] || M, "svelte:component").$$render(e, { data: c }, {}, { default: () => `${F(o[1] || M, "svelte:component").$$render(e, { data: f, form: i }, {}, {})}` })}` : `${F(o[0] || M, "svelte:component").$$render(e, { data: c, form: i }, {}, {})}`}

`}); function te(e, t) { const n = []; e.split(",").forEach((a, o) => { const i = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(a); if (i) { const [, c, f, y = "1"] = i; n.push({ type: c, subtype: f, q: +y, i: o }) } }), n.sort((a, o) => a.q !== o.q ? o.q - a.q : a.subtype === "*" != (o.subtype === "*") ? a.subtype === "*" ? 1 : -1 : a.type === "*" != (o.type === "*") ? a.type === "*" ? 1 : -1 : a.i - o.i); let r, s = 1 / 0; for (const a of t) { const [o, i] = a.split("/"), c = n.findIndex(f => (f.type === o || f.type === "*") && (f.subtype === i || f.subtype === "*")); c !== -1 && c < s && (r = a, s = c) } return r } function et(e, ...t) { const n = e.headers.get("content-type")?.split(";", 1)[0].trim() ?? ""; return t.includes(n) } function ve(e) { return et(e, "application/x-www-form-urlencoded", "multipart/form-data") } function tt(e) { return e instanceof Error || e && e.name && e.message ? e : new Error(JSON.stringify(e)) } function ne(e, t) { return e === "/" || t === "ignore" ? e : t === "never" ? e.endsWith("/") ? e.slice(0, -1) : e : t === "always" && !e.endsWith("/") ? e + "/" : e } function nt(e) { return e.split("%25").map(decodeURI).join("%25") } function rt(e) { for (const t in e) e[t] = decodeURIComponent(e[t]); return e } const st = ["href", "pathname", "search", "searchParams", "toString", "toJSON"]; function at(e, t) { const n = new URL(e); for (const r of st) { let s = n[r]; Object.defineProperty(n, r, { get() { return t(), s }, enumerable: !0, configurable: !0 }) } return n[Symbol.for("nodejs.util.inspect.custom")] = (r, s, a) => a(e, s), ot(n), n } function ot(e) { Object.defineProperty(e, "hash", { get() { throw new Error("Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead") } }) } function Re(e) { for (const t of ["search", "searchParams"]) Object.defineProperty(e, t, { get() { throw new Error(`Cannot access url.${t} on a page with prerendering enabled`) } }) } const re = "/__data.json"; function $e(e) { return e.endsWith(re) } function it(e) { return e.replace(/\/$/, "") + re } function de(e) { return e.slice(0, -re.length) } const Se = { id: "__error" }; function ct(e, t) { return new Response(`${t} method not allowed`, { status: 405, headers: { allow: lt(e).join(", ") } }) } function lt(e) { const t = []; for (const n in ["GET", "POST", "PUT", "PATCH", "DELETE"]) n in e && t.push(n); return (e.GET || e.HEAD) && t.push("HEAD"), t } function P(e, t) { return e.reduce((n, r) => r?.universal?.[t] ?? r?.server?.[t] ?? n, void 0) } function se(e, t, n) { return new Response(e.error_template({ status: t, message: n }), { headers: { "content-type": "text/html; charset=utf-8" }, status: t }) } async function ue(e, t, n) { n = n instanceof U ? n : tt(n); const r = n instanceof U ? n.status : 500, s = await z(e, t, n), a = te(e.request.headers.get("accept") || "text/html", ["application/json", "text/html"]); return $e(new URL(e.request.url).pathname) || a === "application/json" ? new Response(JSON.stringify(s), { status: r, headers: { "content-type": "application/json; charset=utf-8" } }) : se(t, r, s.message) } function z(e, t, n) { return n instanceof U ? n.body : t.handle_error(n, e) } function G(e, t) { return new Response(void 0, { status: e, headers: { location: t } }) } function Oe(e, t) { return t.path ? `Data returned from \`load\` while rendering ${e.route.id} is not serializable: ${t.message} (data${t.path})` : t.path === "" ? `Data returned from \`load\` while rendering ${e.route.id} is not a plain object` : t.message } function Pe(e) { if (!e) return "null"; if (e.type === "error" || e.type === "skip") return JSON.stringify(e); const t = I.stringify(e.data), n = []; return e.uses.dependencies.size > 0 && n.push(`"dependencies":${JSON.stringify(Array.from(e.uses.dependencies))}`), e.uses.params.size > 0 && n.push(`"params":${JSON.stringify(Array.from(e.uses.params))}`), e.uses.parent && n.push('"parent":1'), e.uses.route && n.push('"route":1'), e.uses.url && n.push('"url":1'), `{"type":"data","data":${t},"uses":{${n.join(",")}}${e.slash ? `,"slash":${JSON.stringify(e.slash)}` : ""}}` } async function dt(e, t, n) { const r = e.request.method; let s = t[r]; if (!s && r === "HEAD" && (s = t.GET), !s) return ct(t, r); const a = t.prerender ?? n.prerender_default; if (a && (t.POST || t.PATCH || t.PUT || t.DELETE)) throw new Error("Cannot prerender endpoints that have mutative methods"); if (n.prerendering && !a) { if (n.initiator) throw new Error(`${e.route.id} is not prerenderable`); return new Response(void 0, { status: 204 }) } try { const o = await s(e); if (!(o instanceof Response)) throw new Error(`Invalid response from route ${e.url.pathname}: handler should return a Response object`); return n.prerendering && o.headers.set("x-sveltekit-prerender", String(a)), o } catch (o) { if (o instanceof C) return new Response(void 0, { status: o.status, headers: { location: o.location } }); throw o } } function ut(e) { const { method: t, headers: n } = e.request; if (t === "PUT" || t === "PATCH" || t === "DELETE") return !0; if (t === "POST" && n.get("x-sveltekit-action") === "true") return !1; const r = e.request.headers.get("accept") ?? "*/*"; return te(r, ["*", "text/html"]) !== "text/html" } function fe(e) { return e.filter(t => t != null) } function ft(e) { return te(e.request.headers.get("accept") ?? "*/*", ["application/json", "text/html"]) === "application/json" && e.request.method === "POST" } async function pt(e, t, n) { const r = n?.actions; if (!r) { n && Ce(n); const s = Z(405, "POST method not allowed. No actions exist for this page"); return L({ type: "error", error: await z(e, t, s) }, { status: s.status, headers: { allow: "GET" } }) } qe(r); try { const s = await Ae(e, r); return s instanceof ee ? L({ type: "failure", status: s.status, data: pe(s.data, e.route.id) }) : L({ type: "success", status: s ? 200 : 204, data: pe(s, e.route.id) }) } catch (s) { const a = s; return a instanceof C ? L({ type: "redirect", status: a.status, location: a.location }) : L({ type: "error", error: await z(e, t, Te(a)) }, { status: a instanceof U ? a.status : 500 }) } } function Te(e) { return e instanceof ee ? new Error('Cannot "throw fail()". Use "return fail()"') : e } function L(e, t) { return je(e, t) } function ht(e, t) { return t.server && e.request.method !== "GET" && e.request.method !== "HEAD" } async function mt(e, t) { const n = t.actions; if (!n) return Ce(t), e.setHeaders({ allow: "GET" }), { type: "error", error: Z(405, "POST method not allowed. No actions exist for this page") }; qe(n); try { const r = await Ae(e, n); return r instanceof ee ? { type: "failure", status: r.status, data: r.data } : { type: "success", status: 200, data: r } } catch (r) { const s = r; return s instanceof C ? { type: "redirect", status: s.status, location: s.location } : { type: "error", error: Te(s) } } } function qe(e) { if (e.default && Object.keys(e).length > 1) throw new Error("When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions") } async function Ae(e, t) { const n = new URL(e.request.url); let r = "default"; for (const a of n.searchParams) if (a[0].startsWith("/")) { if (r = a[0].slice(1), r === "default") throw new Error('Cannot use reserved action name "default"'); break } const s = t[r]; if (!s) throw new Error(`No action with name '${r}' found`); if (!ve(e.request)) throw new Error(`Actions expect form-encoded data (received ${e.request.headers.get("content-type")}`); return s(e) } function Ce(e) { for (const t of ["POST", "PUT", "PATCH", "DELETE"]) if (e[t]) throw new Error(`${t} method no longer allowed in +page.server, use actions instead. See the PR for more info: https://github.com/sveltejs/kit/pull/6469`) } function _t(e, t) { return Ue(e, I.uneval, t) } function pe(e, t) { return Ue(e, I.stringify, t) } function Ue(e, t, n) { try { return t(e) } catch (r) { const s = r; if ("path" in s) { let a = `Data returned from action inside ${n} is not serializable: ${s.message}`; throw s.path !== "" && (a += ` (data.${s.path})`), new Error(a) } throw s } } async function ze(e) { for (const t in e) if (typeof e[t]?.then == "function") return Object.fromEntries(await Promise.all(Object.entries(e).map(async ([n, r]) => [n, await r]))); return e } async function ae({ event: e, options: t, state: n, node: r, parent: s }) { if (!r?.server) return null; const a = { dependencies: new Set, params: new Set, parent: !1, route: !1, url: !1 }, o = at(e.url, () => { a.url = !0 }); n.prerendering && Re(o); const i = await r.server.load?.call(null, { ...e, depends: (...f) => { for (const y of f) { const { href: k } = new URL(y, e.url); a.dependencies.add(k) } }, params: new Proxy(e.params, { get: (f, y) => (a.params.add(y), f[y]) }), parent: async () => (a.parent = !0, s()), route: { get id() { return a.route = !0, e.route.id } }, url: o }), c = i ? await ze(i) : null; return t.dev && He(c, e.route.id), { type: "data", data: c, uses: a, slash: r.server.trailingSlash } } async function Ne({ event: e, fetched: t, node: n, parent: r, server_data_promise: s, state: a, resolve_opts: o, csr: i }) { const c = await s; if (!n?.universal?.load) return c?.data ?? null; const f = await n.universal.load.call(null, { url: e.url, params: e.params, data: c?.data ?? null, route: e.route, fetch: async (k, u) => { const _ = k instanceof Request && k.body ? k.clone().body : null, l = await e.fetch(k, u), d = new URL(k instanceof Request ? k.url : k, e.url), h = d.origin === e.url.origin; let m; if (h) a.prerendering && (m = { response: l, body: null }, a.prerendering.dependencies.set(d.pathname, m)); else if ((k instanceof Request ? k.mode : u?.mode ?? "cors") !== "no-cors") { const g = l.headers.get("access-control-allow-origin"); if (!g || g !== e.url.origin && g !== "*") throw new Error(`CORS error: ${g ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`) } const E = new Proxy(l, { get(p, g, v) { async function b() { const j = await p.text(); if (!j || typeof j == "string") { const O = Number(p.status); if (isNaN(O)) throw new Error(`response.status is not a number. value: "${p.status}" type: ${typeof p.status}`); t.push({ url: h ? d.href.slice(e.url.origin.length) : d.href, method: e.request.method, request_body: k instanceof Request && _ ? await yt(_) : u?.body, response_body: j, response: p }) } return m && (m.body = j), j } return g === "arrayBuffer" ? async () => { const j = await p.arrayBuffer(); return m && (m.body = new Uint8Array(j)), j } : g === "text" ? b : g === "json" ? async () => JSON.parse(await b()) : Reflect.get(p, g, p) } }); if (i) { const p = l.headers.get; l.headers.get = g => { const v = g.toLowerCase(), b = p.call(l.headers, v); if (b && !v.startsWith("x-sveltekit-") && !o.filterSerializedResponseHeaders(v, b)) throw new Error(`Failed to get response header "${v}" — it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${e.route})`); return b } } return E }, setHeaders: e.setHeaders, depends: () => { }, parent: r }), y = f ? await ze(f) : null; return He(y, e.route.id), y } async function yt(e) { let t = ""; const n = e.getReader(), r = new TextDecoder; for (; ;) { const { done: s, value: a } = await n.read(); if (s) break; t += r.decode(a) } return t } function He(e, t) { if (e != null && Object.getPrototypeOf(e) !== Object.prototype) throw new Error(`a load function related to route '${t}' returned ${typeof e != "object" ? `a ${typeof e}` : e instanceof Response ? "a Response object" : Array.isArray(e) ? "an array" : "a non-plain object"}, but must return a plain object at the top level (i.e. \`return {...}\`)`) } function V(e) { let t = 5381; if (typeof e == "string") { let n = e.length; for (; n;)t = t * 33 ^ e.charCodeAt(--n) } else if (ArrayBuffer.isView(e)) { const n = new Uint8Array(e.buffer, e.byteOffset, e.byteLength); let r = n.length; for (; r;)t = t * 33 ^ n[--r] } else throw new TypeError("value must be a string or TypedArray"); return (t >>> 0).toString(36) } const De = { "&": "&amp;", '"': "&quot;" }, gt = new RegExp(`[${Object.keys(De).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g"); function Y(e) { return `"${e.replace(gt, n => n.length === 2 ? n : De[n] ?? `&#${n.charCodeAt(0)};`)}"` } const Ie = { "<": "\\u003C", "\u2028": "\\u2028", "\u2029": "\\u2029" }, wt = new RegExp(`[${Object.keys(Ie).join("")}]`, "g"); function bt(e, t, n = !1) { const r = {}; let s = null, a = null; for (const [f, y] of e.response.headers) t(f, y) && (r[f] = y), f === "cache-control" && (s = y), f === "age" && (a = y); const o = { status: e.response.status, statusText: e.response.statusText, headers: r, body: e.response_body }, i = JSON.stringify(o).replace(wt, f => Ie[f]), c = ['type="application/json"', "data-sveltekit-fetched", `data-url=${Y(e.url)}`]; if (e.request_body && c.push(`data-hash=${Y(V(e.request_body))}`), !n && e.method === "GET" && s) { const f = /s-maxage=(\d+)/g.exec(s) ?? /max-age=(\d+)/g.exec(s); if (f) { const y = +f[1] - +(a ?? "0"); c.push(`data-ttl="${y}"`) } } return `<script ${c.join(" ")}>${i}<\/script>` } const q = JSON.stringify, kt = new TextEncoder; function he(e) { K[0] || Et(); const t = Le.slice(0), n = jt(e); for (let s = 0; s < n.length; s += 16) { const a = n.subarray(s, s + 16); let o, i, c, f = t[0], y = t[1], k = t[2], u = t[3], _ = t[4], l = t[5], d = t[6], h = t[7]; for (let m = 0; m < 64; m++)m < 16 ? o = a[m] : (i = a[m + 1 & 15], c = a[m + 14 & 15], o = a[m & 15] = (i >>> 7 ^ i >>> 18 ^ i >>> 3 ^ i << 25 ^ i << 14) + (c >>> 17 ^ c >>> 19 ^ c >>> 10 ^ c << 15 ^ c << 13) + a[m & 15] + a[m + 9 & 15] | 0), o = o + h + (_ >>> 6 ^ _ >>> 11 ^ _ >>> 25 ^ _ << 26 ^ _ << 21 ^ _ << 7) + (d ^ _ & (l ^ d)) + K[m], h = d, d = l, l = _, _ = u + o | 0, u = k, k = y, y = f, f = o + (y & k ^ u & (y ^ k)) + (y >>> 2 ^ y >>> 13 ^ y >>> 22 ^ y << 30 ^ y << 19 ^ y << 10) | 0; t[0] = t[0] + f | 0, t[1] = t[1] + y | 0, t[2] = t[2] + k | 0, t[3] = t[3] + u | 0, t[4] = t[4] + _ | 0, t[5] = t[5] + l | 0, t[6] = t[6] + d | 0, t[7] = t[7] + h | 0 } const r = new Uint8Array(t.buffer); return We(r), Je(r) } const Le = new Uint32Array(8), K = new Uint32Array(64); function Et() { function e(n) { return (n - Math.floor(n)) * 4294967296 } let t = 2; for (let n = 0; n < 64; t++) { let r = !0; for (let s = 2; s * s <= t; s++)if (t % s === 0) { r = !1; break } r && (n < 8 && (Le[n] = e(t ** (1 / 2))), K[n] = e(t ** (1 / 3)), n++) } } function We(e) { for (let t = 0; t < e.length; t += 4) { const n = e[t + 0], r = e[t + 1], s = e[t + 2], a = e[t + 3]; e[t + 0] = a, e[t + 1] = s, e[t + 2] = r, e[t + 3] = n } } function jt(e) { const t = kt.encode(e), n = t.length * 8, r = 512 * Math.ceil((n + 65) / 512), s = new Uint8Array(r / 8); s.set(t), s[t.length] = 128, We(s); const a = new Uint32Array(s.buffer); return a[a.length - 2] = Math.floor(n / 4294967296), a[a.length - 1] = n, a } const A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""); function Je(e) { const t = e.length; let n = "", r; for (r = 2; r < t; r += 3)n += A[e[r - 2] >> 2], n += A[(e[r - 2] & 3) << 4 | e[r - 1] >> 4], n += A[(e[r - 1] & 15) << 2 | e[r] >> 6], n += A[e[r] & 63]; return r === t + 1 && (n += A[e[r - 2] >> 2], n += A[(e[r - 2] & 3) << 4], n += "=="), r === t && (n += A[e[r - 2] >> 2], n += A[(e[r - 2] & 3) << 4 | e[r - 1] >> 4], n += A[(e[r - 1] & 15) << 2], n += "="), n } const me = new Uint8Array(16); function xt() { return crypto.getRandomValues(me), Je(me) } const vt = new Set(["self", "unsafe-eval", "unsafe-hashes", "unsafe-inline", "none", "strict-dynamic", "report-sample", "wasm-unsafe-eval"]), Rt = /^(nonce|sha\d\d\d)-/; class Be { #n; #r; #s; #a; #e; #t; #o; constructor(t, n, r, s) { this.#n = t, this.#a = s ? { ...n } : n; const a = this.#a; if (s) { const c = a["style-src"] || a["default-src"]; c && !c.includes("unsafe-inline") && (a["style-src"] = [...c, "unsafe-inline"]) } this.#e = [], this.#t = []; const o = a["script-src"] || a["default-src"], i = a["style-src"] || a["default-src"]; this.#r = !!o && o.filter(c => c !== "unsafe-inline").length > 0, this.#s = !s && !!i && i.filter(c => c !== "unsafe-inline").length > 0, this.script_needs_nonce = this.#r && !this.#n, this.style_needs_nonce = this.#s && !this.#n, this.#o = r } add_script(t) { this.#r && (this.#n ? this.#e.push(`sha256-${he(t)}`) : this.#e.length === 0 && this.#e.push(`nonce-${this.#o}`)) } add_style(t) { this.#s && (this.#n ? this.#t.push(`sha256-${he(t)}`) : this.#t.length === 0 && this.#t.push(`nonce-${this.#o}`)) } get_header(t = !1) { const n = [], r = { ...this.#a }; this.#t.length > 0 && (r["style-src"] = [...r["style-src"] || r["default-src"] || [], ...this.#t]), this.#e.length > 0 && (r["script-src"] = [...r["script-src"] || r["default-src"] || [], ...this.#e]); for (const s in r) { if (t && (s === "frame-ancestors" || s === "report-uri" || s === "sandbox")) continue; const a = r[s]; if (!a) continue; const o = [s]; Array.isArray(a) && a.forEach(i => { vt.has(i) || Rt.test(i) ? o.push(`'${i}'`) : o.push(i) }), n.push(o.join(" ")) } return n.join("; ") } } class $t extends Be { get_meta() { return `<meta http-equiv="content-security-policy" content=${Y(this.get_header(!0))}>` } } class St extends Be { constructor(t, n, r, s) { if (super(t, n, r, s), Object.values(n).filter(a => !!a).length > 0) { const a = n["report-to"]?.length ?? 0 > 0, o = n["report-uri"]?.length ?? 0 > 0; if (!a && !o) throw Error("`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both") } } } class Ot { nonce = xt(); csp_provider; report_only_provider; constructor({ mode: t, directives: n, reportOnly: r }, { prerender: s, dev: a }) { const o = t === "hash" || t === "auto" && s; this.csp_provider = new $t(o, n, this.nonce, a), this.report_only_provider = new St(o, r, this.nonce, a) } get script_needs_nonce() { return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce } get style_needs_nonce() { return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce } add_script(t) { this.csp_provider.add_script(t), this.report_only_provider.add_script(t) } add_style(t) { this.csp_provider.add_style(t), this.report_only_provider.add_style(t) } } const Pt = { ...Qe(!1), check: () => !1 }; async function D({ branch: e, fetched: t, options: n, state: r, page_config: s, status: a, error: o = null, event: i, resolve_opts: c, action_result: f }) {
	if (r.prerendering) { if (n.csp.mode === "nonce") throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"'); if (n.app_template_contains_nonce) throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%") } const { entry: y } = n.manifest._, k = new Set(y.stylesheets), u = new Set(y.imports), _ = new Set(n.manifest._.entry.fonts), l = new Set, d = new Map; let h; const m = f?.type === "success" || f?.type === "failure" ? f.data ?? null : null; if (s.ssr) { const w = { stores: { page: ce(null), navigating: ce(null), updated: Pt }, components: await Promise.all(e.map(({ node: x }) => x.component())), form: m }; let R = {}; for (let x = 0; x < e.length; x += 1)R = { ...R, ...e[x].data }, w[`data_${x}`] = R; w.page = { error: o, params: i.params, route: i.route, status: a, url: i.url, data: R, form: m }, h = n.root.render(w); for (const { node: x } of e) x.imports && x.imports.forEach($ => u.add($)), x.stylesheets && x.stylesheets.forEach($ => k.add($)), x.fonts && x.fonts.forEach($ => _.add($)), x.inline_styles && Object.entries(await x.inline_styles()).forEach(([$, N]) => d.set($, N)) } else h = { head: "", html: "", css: { code: "", map: null } }; let E = "", p = h.html; const g = new Ot(n.csp, { dev: n.dev, prerender: !!r.prerendering }), v = V(p); let b; if (n.paths.assets) b = n.paths.assets; else if (r.prerendering?.fallback) b = n.paths.base; else { const w = i.url.pathname.slice(n.paths.base.length).split("/").slice(2); b = w.length > 0 ? w.map(() => "..").join("/") : "." } const j = w => w.startsWith("/") ? w : `${b}/${w}`, O = { data: "", form: "null" }; try { O.data = `[${e.map(({ server_data: w }) => { if (w?.type === "data") { const R = I.uneval(w.data), x = []; return w.uses.dependencies.size > 0 && x.push(`dependencies:${q(Array.from(w.uses.dependencies))}`), w.uses.params.size > 0 && x.push(`params:${q(Array.from(w.uses.params))}`), w.uses.parent && x.push("parent:1"), w.uses.route && x.push("route:1"), w.uses.url && x.push("url:1"), `{type:"data",data:${R},uses:{${x.join(",")}}${w.slash ? `,slash:${q(w.slash)}` : ""}}` } return q(w) }).join(",")}]` } catch (w) { const R = w; throw new Error(Oe(i, R)) } if (m && (O.form = _t(m, i.route.id)), d.size > 0) {
		const w = Array.from(d.values()).join(`
`), R = []; n.dev && R.push(" data-sveltekit"), g.style_needs_nonce && R.push(` nonce="${g.nonce}"`), g.add_style(w), E += `
	<style${R.join("")}>${w}</style>`
	} for (const w of k) {
		const R = j(w); if (c.preload({ type: "css", path: R })) {
			const x = []; if (g.style_needs_nonce && x.push(`nonce="${g.nonce}"`), d.has(w)) x.push("disabled", 'media="(max-width: 0)"'); else { const $ = ['rel="preload"', 'as="style"'].concat(x); l.add(`<${encodeURI(R)}>; ${$.join(";")}; nopush`) } x.unshift('rel="stylesheet"'), E += `
		<link href="${R}" ${x.join(" ")}>`
		}
	} for (const w of _) {
		const R = j(w); if (c.preload({ type: "font", path: R })) {
			const $ = ['rel="preload"', 'as="font"', `type="font/${w.slice(w.lastIndexOf(".") + 1)}"`, `href="${R}"`, "crossorigin"]; E += `
		<link ${$.join(" ")}>`
		}
	} if (s.csr) {
		const w = [`env: ${q(n.public_env)}`, `paths: ${q(n.paths)}`, `target: document.querySelector('[data-sveltekit-hydrate="${v}"]').parentNode`, `version: ${q(n.version)}`]; if (s.ssr) {
			const $ = [`node_ids: [${e.map(({ node: N }) => N.index).join(", ")}]`, `data: ${O.data}`, `form: ${O.form}`]; a !== 200 && $.push(`status: ${a}`), o && $.push(`error: ${I.uneval(o)}`), n.embedded && $.push(`params: ${I.uneval(i.params)}`, `route: ${q(i.route)}`), w.push(`hydrate: {
					${$.join(`,
					`)}
				}`)
		} const R = `
			import { start } from ${q(j(y.file))};

			start({
				${w.join(`,
				`)}
			});
		`; for (const $ of u) {
			const N = j($); c.preload({ type: "js", path: N }) && (l.add(`<${encodeURI(N)}>; rel="modulepreload"; nopush`), r.prerendering && (E += `
		<link rel="modulepreload" href="${N}">`))
		} const x = ['type="module"', `data-sveltekit-hydrate="${v}"`]; g.add_script(R), g.script_needs_nonce && x.push(`nonce="${g.nonce}"`), p += `
		<script ${x.join(" ")}>${R}<\/script>`
	} if (s.ssr && s.csr && (p += `
	${t.map(w => bt(w, c.filterSerializedResponseHeaders, !!r.prerendering)).join(`
	`)}`), n.service_worker) {
		const w = n.dev ? ", { type: 'module' }" : "", R = `
			if ('serviceWorker' in navigator) {
				addEventListener('load', function () {
					navigator.serviceWorker.register('${j("service-worker.js")}'${w});
				});
			}
		`; g.add_script(R), E += `
		<script${g.script_needs_nonce ? ` nonce="${g.nonce}"` : ""}>${R}<\/script>`
	} if (r.prerendering) {
		const w = [], R = g.csp_provider.get_meta(); R && w.push(R), r.prerendering.cache && w.push(`<meta http-equiv="cache-control" content="${r.prerendering.cache}">`), w.length > 0 && (E = w.join(`
`) + E)
	} E += h.head; const T = await c.transformPageChunk({ html: n.app_template({ head: E, body: p, assets: b, nonce: g.nonce }), done: !0 }) || "", H = new Headers({ "x-sveltekit-page": "true", "content-type": "text/html", etag: `"${V(T)}"` }); if (!r.prerendering) { const w = g.csp_provider.get_header(); w && H.set("content-security-policy", w); const R = g.report_only_provider.get_header(); R && H.set("content-security-policy-report-only", R), l.size && H.set("link", Array.from(l).join(", ")) } return new Response(T, { status: a, headers: H })
} async function Ge({ event: e, options: t, state: n, status: r, error: s, resolve_opts: a }) { const o = []; try { const i = [], c = await t.manifest._.nodes[0](), f = P([c], "ssr") ?? !0, y = P([c], "csr") ?? !0; if (f) { n.initiator = Se; const k = ae({ event: e, options: t, state: n, node: c, parent: async () => ({}) }), u = await k, _ = await Ne({ event: e, fetched: o, node: c, parent: async () => ({}), resolve_opts: a, server_data_promise: k, state: n, csr: y }); i.push({ node: c, server_data: u, data: _ }, { node: await t.manifest._.nodes[1](), data: null, server_data: null }) } return await D({ options: t, state: n, page_config: { ssr: f, csr: P([c], "csr") ?? !0 }, status: r, error: await z(e, t, s), branch: i, fetched: o, event: e, resolve_opts: a }) } catch (i) { return i instanceof C ? G(i.status, i.location) : se(t, i instanceof U ? i.status : 500, (await z(e, t, i)).message) } } async function Tt(e, t, n, r, s, a) { if (s.initiator === t) return new Response(`Not found: ${e.url.pathname}`, { status: 404 }); if (s.initiator = t, ft(e)) { const o = await r.manifest._.nodes[n.leaf](); return pt(e, r, o?.server) } try { const o = await Promise.all([...n.layouts.map(p => p == null ? p : r.manifest._.nodes[p]()), r.manifest._.nodes[n.leaf]()]), i = o.at(-1); let c = 200, f; if (ht(e, i)) { if (f = await mt(e, i.server), f?.type === "redirect") return G(303, f.location); if (f?.type === "error") { const p = f.error; c = p instanceof U ? p.status : 500 } f?.type === "failure" && (c = f.status) } const y = o.some(p => p?.server), k = it(e.url.pathname), u = P(o, "prerender"); if (u) { const p = i.server; if (p && p.actions) throw new Error("Cannot prerender pages with actions") } else if (s.prerendering) return u !== !1 && P(o, "ssr") === !1 && !i.server?.actions ? await D({ branch: [], fetched: [], page_config: { ssr: !1, csr: P(o, "csr") ?? !0 }, status: c, error: null, event: e, options: r, state: s, resolve_opts: a }) : new Response(void 0, { status: 204 }); s.prerender_default = u; const _ = []; if (P(o, "ssr") === !1) return await D({ branch: [], fetched: _, page_config: { ssr: !1, csr: P(o, "csr") ?? !0 }, status: c, error: null, event: e, options: r, state: s, resolve_opts: a }); let l = [], d = null; const h = o.map((p, g) => { if (d) throw d; return Promise.resolve().then(async () => { try { if (p === i && f?.type === "error") throw f.error; return await ae({ event: e, options: r, state: s, node: p, parent: async () => { const v = {}; for (let b = 0; b < g; b += 1) { const j = await h[b]; j && Object.assign(v, await j.data) } return v } }) } catch (v) { throw d = v, d } }) }), m = P(o, "csr") ?? !0, E = o.map((p, g) => { if (d) throw d; return Promise.resolve().then(async () => { try { return await Ne({ event: e, fetched: _, node: p, parent: async () => { const v = {}; for (let b = 0; b < g; b += 1)Object.assign(v, await E[b]); return v }, resolve_opts: a, server_data_promise: h[g], state: s, csr: m }) } catch (v) { throw d = v, d } }) }); for (const p of h) p.catch(() => { }); for (const p of E) p.catch(() => { }); for (let p = 0; p < o.length; p += 1) { const g = o[p]; if (g) try { const v = await h[p], b = await E[p]; l.push({ node: g, server_data: v, data: b }) } catch (v) { const b = v; if (b instanceof C) { if (s.prerendering && y) { const T = JSON.stringify({ type: "redirect", location: b.location }); s.prerendering.dependencies.set(k, { response: new Response(T), body: T }) } return G(b.status, b.location) } const j = b instanceof U ? b.status : 500, O = await z(e, r, b); for (; p--;)if (n.errors[p]) { const T = n.errors[p], H = await r.manifest._.nodes[T](); let w = p; for (; !l[w];)w -= 1; return await D({ event: e, options: r, state: s, resolve_opts: a, page_config: { ssr: !0, csr: !0 }, status: j, error: O, branch: fe(l.slice(0, w + 1)).concat({ node: H, data: null, server_data: null }), fetched: _ }) } return se(r, j, O.message) } else l.push(null) } if (s.prerendering && y) { const p = `{"type":"data","nodes":[${l.map(g => Pe(g?.server_data)).join(",")}]}`; s.prerendering.dependencies.set(k, { response: new Response(p), body: p }) } return await D({ event: e, options: r, state: s, resolve_opts: a, page_config: { csr: P(o, "csr") ?? !0, ssr: !0 }, status: c, error: null, branch: fe(l), action_result: f, fetched: _ }) } catch (o) { return await Ge({ event: e, options: r, state: s, status: 500, error: o, resolve_opts: a }) } } function qt(e, t, n) { const r = {}, s = e.slice(1); let a = ""; for (let o = 0; o < t.length; o += 1) { const i = t[o]; let c = s[o]; if (i.chained && i.rest && a && (c = c ? a + "/" + c : a), a = "", c === void 0) i.rest && (r[i.name] = ""); else { if (i.matcher && !n[i.matcher](c)) { if (i.optional && i.chained) { let f = s.indexOf(void 0, o); if (f === -1) { const y = t[o + 1]; if (y?.rest && y.chained) a = c; else return } for (; f >= o;)s[f] = s[f - 1], f -= 1; continue } return } r[i.name] = c } } if (!a) return r } function At(e) { let t = !1, n; return () => t ? n : (t = !0, n = e()) } const _e = "x-sveltekit-invalidated"; async function Ct(e, t, n, r, s, a) { if (!t.page) return new Response(void 0, { status: 404 }); try { const o = [...t.page.layouts, t.page.leaf], i = s ?? o.map(() => !0); let c = !1; const f = new URL(e.url); f.pathname = ne(f.pathname, a); const y = { ...e, url: f }, k = o.map((d, h) => At(async () => { try { if (c) return { type: "skip" }; const m = d == null ? d : await n.manifest._.nodes[d](); return ae({ event: y, options: n, state: r, node: m, parent: async () => { const E = {}; for (let p = 0; p < h; p += 1) { const g = await k[p](); g && Object.assign(E, g.data) } return E } }) } catch (m) { throw c = !0, m } })), u = k.map(async (d, h) => i[h] ? d() : { type: "skip" }); let _ = u.length; const l = await Promise.all(u.map((d, h) => d.catch(async m => { if (m instanceof C) throw m; return _ = Math.min(_, h + 1), { type: "error", error: await z(e, n, m), status: m instanceof U ? m.status : void 0 } }))); try { const h = `{"type":"data","nodes":[${l.slice(0, _).map(Pe).join(",")}]}`; return B(h) } catch (d) { const h = d; return B(JSON.stringify(Oe(e, h)), 500) } } catch (o) { const i = o; return i instanceof C ? X(i) : B(JSON.stringify(await z(e, n, i))) } } function B(e, t = 200) { return new Response(e, { status: t, headers: { "content-type": "application/json", "cache-control": "private, no-store" } }) } function X(e) { return B(JSON.stringify({ type: "redirect", location: e.location })) } const S = {}; function Ut(e, t, n, r) { const s = e.headers.get("cookie") ?? "", a = W(s, { decode: u => u }), o = ne(t.pathname, r), i = o.split("/").slice(0, -1).join("/") || "/"; if (n) { const u = W(s, { decode: decodeURIComponent }); for (const _ of Object.keys(S)) S[_] = new Set([...S[_]].filter(l => !J(o, l) || _ in u)); for (const _ in u) S[_] = S[_] ?? new Set, [...S[_]].some(l => J(o, l)) || S[_].add(i) } const c = {}, f = { httpOnly: !0, sameSite: "lax", secure: !(t.hostname === "localhost" && t.protocol === "http:") }, y = { get(u, _) { const l = c[u]; if (l && ye(t.hostname, l.options.domain) && J(t.pathname, l.options.path)) return l.value; const d = _?.decode || decodeURIComponent, m = W(s, { decode: d })[u]; if (!n || m) return m; const E = new Set([...S[u] ?? []]); l && E.add(l.options.path ?? i), E.size > 0 && console.warn(`Cookie with name '${u}' was not found at path '${t.pathname}', but a cookie with that name exists at these paths: '${[...E].join("', '")}'. Did you mean to set its 'path' to '/' instead?`) }, set(u, _, l = {}) { let d = l.path ?? i; if (c[u] = { name: u, value: _, options: { ...f, ...l, path: d } }, n) if (S[u] = S[u] ?? new Set, _) S[u].add(d); else { if (!S[u].has(d) && S[u].size > 0) { const h = `'${Array.from(S[u]).join("', '")}'`; console.warn(`Trying to delete cookie '${u}' at path '${d}', but a cookie with that name only exists at these paths: ${h}.`) } S[u].delete(d) } }, delete(u, _ = {}) { y.set(u, "", { ..._, maxAge: 0 }) }, serialize(u, _, l) { return xe(u, _, { ...f, ...l }) } }; function k(u, _) { const l = { ...a }; for (const d in c) { const h = c[d]; if (!ye(u.hostname, h.options.domain) || !J(u.pathname, h.options.path)) continue; const m = h.options.encode || encodeURIComponent; l[h.name] = m(h.value) } if (_) { const d = W(_, { decode: h => h }); for (const h in d) l[h] = d[h] } return Object.entries(l).map(([d, h]) => `${d}=${h}`).join("; ") } return { cookies: y, new_cookies: c, get_cookie_header: k } } function ye(e, t) { if (!t) return !0; const n = t[0] === "." ? t.slice(1) : t; return e === n ? !0 : e.endsWith("." + n) } function J(e, t) { if (!t) return !0; const n = t.endsWith("/") ? t.slice(0, -1) : t; return e === n ? !0 : e.startsWith(n + "/") } function zt(e, t) { for (const n of t) { const { name: r, value: s, options: a } = n; e.append("set-cookie", xe(r, s, a)) } } function Nt({ event: e, options: t, state: n, get_cookie_header: r }) { return async (s, a) => { const o = ge(s, a, e.url), i = a?.body; let c = (s instanceof Request ? s.mode : a?.mode) ?? "cors", f = (s instanceof Request ? s.credentials : a?.credentials) ?? "same-origin"; return await t.hooks.handleFetch({ event: e, request: o, fetch: async (y, k) => { const u = ge(y, k, e.url), _ = new URL(u.url); if (u.headers.has("origin") || u.headers.set("origin", e.url.origin), y !== o && (c = (y instanceof Request ? y.mode : k?.mode) ?? "cors", f = (y instanceof Request ? y.credentials : k?.credentials) ?? "same-origin"), (u.method === "GET" || u.method === "HEAD") && (c === "no-cors" && _.origin !== e.url.origin || _.origin === e.url.origin) && u.headers.delete("origin"), _.origin !== e.url.origin) { if (`.${_.hostname}`.endsWith(`.${e.url.hostname}`) && f !== "omit") { const j = r(_, u.headers.get("cookie")); j && u.headers.set("cookie", j) } let b = await fetch(u); return c === "no-cors" && (b = new Response("", { status: b.status, statusText: b.statusText, headers: b.headers })), b } let l; const d = t.paths.assets || t.paths.base, h = decodeURIComponent(_.pathname), m = (h.startsWith(d) ? h.slice(d.length) : h).slice(1), E = `${m}/index.html`, p = t.manifest.assets.has(m), g = t.manifest.assets.has(E); if (p || g) { const b = p ? m : E; if (t.read) { const j = p ? t.manifest.mimeTypes[m.slice(m.lastIndexOf("."))] : "text/html"; return new Response(t.read(b), { headers: j ? { "content-type": j } : {} }) } return await fetch(u) } if (f !== "omit") { const b = r(_, u.headers.get("cookie")); b && u.headers.set("cookie", b); const j = e.request.headers.get("authorization"); j && !u.headers.has("authorization") && u.headers.set("authorization", j) } if (i && typeof i != "string" && !ArrayBuffer.isView(i)) throw new Error("Request body must be a string or TypedArray"); u.headers.has("accept") || u.headers.set("accept", "*/*"), u.headers.has("accept-language") || u.headers.set("accept-language", e.request.headers.get("accept-language")), l = await Fe(u, t, n); const v = l.headers.get("set-cookie"); if (v) for (const b of le.splitCookiesString(v)) { const { name: j, value: O, ...T } = le.parseString(b); e.cookies.set(j, O, T) } return l } }) } } function ge(e, t, n) { return e instanceof Request ? e : new Request(typeof e == "string" ? new URL(e, n) : e, t) } function oe(e) { const t = new Set(e); function n(r, s) { if (r) { for (const a in r) if (a[0] !== "_" && !t.has(a)) { const o = e.join(", "); throw new Error(`Invalid export '${a}'${s ? ` in ${s}` : ""} (valid exports are ${o}, or anything with a '_' prefix)`) } } } return n } const Gt = oe(["load", "prerender", "csr", "ssr", "trailingSlash"]), Ft = oe(["load", "prerender", "csr", "ssr", "actions", "trailingSlash"]), Mt = oe(["GET", "POST", "PATCH", "PUT", "DELETE", "prerender", "trailingSlash"]), we = ({ html: e }) => e, be = () => !1, ke = ({ type: e }) => e === "js" || e === "css"; async function Fe(e, t, n) { let r = new URL(e.url); if (t.csrf.check_origin && e.method === "POST" && e.headers.get("origin") !== r.origin && ve(e)) { const d = Z(403, `Cross-site ${e.method} form submissions are forbidden`); return e.headers.get("accept") === "application/json" ? je(d.body, { status: d.status }) : new Response(d.body.message, { status: d.status }) } let s; try { s = nt(r.pathname) } catch { return new Response("Malformed URI", { status: 400 }) } let a = null, o = {}; if (t.paths.base && !n.prerendering?.fallback) { if (!s.startsWith(t.paths.base)) return new Response("Not found", { status: 404 }); s = s.slice(t.paths.base.length) || "/" } const i = $e(s); let c; if (i && (s = de(s) || "/", r.pathname = de(r.pathname) || "/", c = r.searchParams.get(_e)?.split("_").map(Boolean), r.searchParams.delete(_e)), !n.prerendering?.fallback) { const l = await t.manifest._.matchers(); for (const d of t.manifest._.routes) { const h = d.pattern.exec(s); if (!h) continue; const m = qt(h, d.params, l); if (m) { a = d, o = rt(m); break } } } let f; const y = {}, k = { cookies: null, fetch: null, getClientAddress: n.getClientAddress || (() => { throw new Error("@sveltejs/adapter-cloudflare-workers does not specify getClientAddress. Please raise an issue") }), locals: {}, params: o, platform: n.platform, request: e, route: { id: a?.id ?? null }, setHeaders: l => { for (const d in l) { const h = d.toLowerCase(), m = l[d]; if (h === "set-cookie") throw new Error("Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"); if (h in y) throw new Error(`"${d}" header is already set`); y[h] = m, n.prerendering && h === "cache-control" && (n.prerendering.cache = m) } }, url: r, isDataRequest: i }; let u = { transformPageChunk: we, filterSerializedResponseHeaders: be, preload: ke }; try { if (a && !i) { if (a.page) { const p = await Promise.all([...a.page.layouts.map(g => g == null ? g : t.manifest._.nodes[g]()), t.manifest._.nodes[a.page.leaf]()]); f = P(p, "trailingSlash") } else a.endpoint && (f = (await a.endpoint()).trailingSlash); const E = ne(r.pathname, f ?? "never"); if (E !== r.pathname && !n.prerendering?.fallback) return new Response(void 0, { status: 301, headers: { "x-sveltekit-normalize": "1", location: (E.startsWith("//") ? r.origin + E : E) + (r.search === "?" ? "" : r.search) } }) } const { cookies: l, new_cookies: d, get_cookie_header: h } = Ut(e, r, t.dev, f ?? "never"); k.cookies = l, k.fetch = Nt({ event: k, options: t, state: n, get_cookie_header: h }), n.prerendering && !n.prerendering.fallback && Re(r); const m = await t.hooks.handle({ event: k, resolve: (E, p) => _(E, p).then(g => { for (const v in y) { const b = y[v]; g.headers.set(v, b) } return zt(g.headers, Object.values(d)), n.prerendering && E.route.id !== null && g.headers.set("x-sveltekit-routeid", encodeURI(E.route.id)), g }) }); if (m.status === 200 && m.headers.has("etag")) { let E = e.headers.get("if-none-match"); E?.startsWith('W/"') && (E = E.substring(2)); const p = m.headers.get("etag"); if (E === p) { const g = new Headers({ etag: p }); for (const v of ["cache-control", "content-location", "date", "expires", "vary", "set-cookie"]) { const b = m.headers.get(v); b && g.set(v, b) } return new Response(void 0, { status: 304, headers: g }) } } if (i && m.status >= 300 && m.status <= 308) { const E = m.headers.get("location"); if (E) return X(new C(m.status, E)) } return m } catch (l) { return l instanceof C ? i ? X(l) : G(l.status, l.location) : await ue(k, t, l) } async function _(l, d) { try { if (d) { if ("ssr" in d) throw new Error("ssr has been removed, set it in the appropriate +layout.js instead. See the PR for more information: https://github.com/sveltejs/kit/pull/6197"); u = { transformPageChunk: d.transformPageChunk || we, filterSerializedResponseHeaders: d.filterSerializedResponseHeaders || be, preload: d.preload || ke } } if (n.prerendering?.fallback) return await D({ event: l, options: t, state: n, page_config: { ssr: !1, csr: !0 }, status: 200, error: null, branch: [], fetched: [], resolve_opts: u }); if (a) { let h; if (i) h = await Ct(l, a, t, n, c, f ?? "never"); else if (a.endpoint && (!a.page || ut(l))) h = await dt(l, await a.endpoint(), n); else if (a.page) h = await Tt(l, a, a.page, t, n, u); else throw new Error("This should never happen"); return h } return n.initiator === Se ? new Response("Internal Server Error", { status: 500 }) : n.initiator ? n.prerendering ? new Response("not found", { status: 404 }) : await fetch(e) : await Ge({ event: l, options: t, state: n, status: 404, error: new Error(`Not found: ${l.url.pathname}`), resolve_opts: u }) } catch (h) { return await ue(l, t, h) } finally { l.cookies.set = () => { throw new Error("Cannot use `cookies.set(...)` after the response has been generated") }, l.setHeaders = () => { throw new Error("Cannot use `setHeaders(...)` after the response has been generated") } } } } let Q = "", Me = ""; function Ve(e) { Q = e.base, Me = e.assets || Q } const Ht = ({ head: e, body: t, assets: n, nonce: r }) => `<!DOCTYPE html>
<html
	lang="en"
	class=""
>
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, maximum-scale=1.0,user-scalable=0"
		/>
		<link
			rel="icon"
			href="/assets/favicon.ico"
		/>
		<link
			rel="shortcut icon"
			type="image/svg"
			href="/logo.svg"
		/>
		<link
			rel="shortcut icon"
			type="image/png"
			href="/favicon.png"
		/>

		<meta
			name="application-name"
			content="MusicTunes"
		/>
		<meta
			name="msapplication-TileColor"
			content="#da532c"
		/>

		<meta
			name="og:site_name"
			content="MusicTunes"
		/>

		<!-- Apple Metatags-->
		<meta
			name="apple-mobile-web-app-capable"
			content="yes"
		/>
		<meta
			name="apple-mobile-web-app-status-bar-style"
			content="black-translucent"
		/>
		<meta
			content="yes"
			name="apple-touch-fullscreen"
		/>
		<meta
			name="apple-mobile-web-app-title"
			content="MusicTunes"
		/>
		<link
			rel="apple-touch-icon"
			sizes="180x180"
			href="/apple-touch-icon.png"
		/>
		<link
			rel="mask-icon"
			href="/assets/safari-pinned-tab.svg"
			color="#5bbad5"
		/>
		<link
			rel="preload"
			type="image/svg+xml"
			href="/icons.svg"
		/>
		<meta
			name="theme-color"
			content="#17171d"
		/>
		<meta
			name="apple-mobile-web-app-orientations"
			content="portrait"
		/>
		<meta
			name="apple-mobile-web-app-status-bar-style"
			content="black"
		/>

		<!-- SvelteKit tags -->
		<link
			rel="manifest"
			href="/manifest.json"
		/>

		<script>
			var parcelRequire;

			// if (!("appearance" in localStorage)) {
			// 	localStorage.theme = "Dark";
			// }
			const hasSettings = localStorage.settings;
			if (!hasSettings) document.documentElement.classList.add("Dark");
			else document.documentElement.classList.add(JSON.parse(hasSettings)?.appearance?.Theme ?? "Dark");
		<\/script>
		`+ e + `
	</head>
	<div id="app">`+ t + `</div>
</html>
`, Dt = ({ status: e, message: t }) => `<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>`+ t + `</title>

		<style>
			body {
				font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
					Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid #ccc;
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">`+ e + `</span>
			<div class="message">
				<h1>`+ t + `</h1>
			</div>
		</div>
	</body>
</html>
`; let Ye = null; Ve({ base: "", assets: "" }); let Ee = "https"; function Vt(e) { Ee = e.protocol || Ee, Ve(e.paths), e.building, Ye = e.read } class Yt { constructor(t) { this.options = { csp: { mode: "auto", directives: { "upgrade-insecure-requests": !1, "block-all-mixed-content": !1 }, reportOnly: { "upgrade-insecure-requests": !1, "block-all-mixed-content": !1 } }, csrf: { check_origin: !0 }, dev: !1, embedded: !1, handle_error: (n, r) => this.options.hooks.handleError({ error: n, event: r }) ?? { message: r.route.id != null ? "Internal Error" : "Not Found" }, hooks: null, manifest: t, paths: { base: Q, assets: Me }, public_env: {}, read: Ye, root: Ze, service_worker: !0, app_template: Ht, app_template_contains_nonce: !1, error_template: Dt, version: "1684008270896" } } async init({ env: t }) { const n = Object.entries(t); Object.fromEntries(n.filter(([s]) => !s.startsWith("PUBLIC_"))); const r = Object.fromEntries(n.filter(([s]) => s.startsWith("PUBLIC_"))); if (this.options.public_env = r, !this.options.hooks) { const s = await import("./chunks/hooks.server.js"); this.options.hooks = { handle: s.handle || (({ event: a, resolve: o }) => o(a)), handleError: s.handleError || (({ error: a }) => console.error(a.stack)), handleFetch: s.handleFetch || (({ request: a, fetch: o }) => o(a)) } } } async respond(t, n = {}) { if (!(t instanceof Request)) throw new Error("The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details"); return Fe(t, this.options, n) } } export { Yt as Server, Vt as override };
